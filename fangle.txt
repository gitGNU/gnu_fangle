

fangle

 Sam Liddicott

sam@liddicott.com



August 2009





∗    modes["sh", "\"", "submodes"]="\\\\||\\$\\(";
∗    modes["sh", "\"", "submodes"]="\\\\||\\$\\(";
∗    modes["sh", "\"", "submodes"]="\\\\||\\$\\(";
∗    modes["sh", "\"", "submodes"]="\\\\||\\$\\(";
Introduction 
Fangle is a tool for fangled literate programming. Newfangled is defined as New and often needlessly novel by TheFreeDictionary.com.
In this case, fangled means yet another not-so-new1. but improved.  ^1 method for literate programming.
Literate Programming has a long history starting with the great Donald Knuth himself, whose literate programming tools seem to make use of as many escape sequences for semantic markup as TeX (also by Donald Knuth).
Norman Ramsey wrote the Noweb set of tools (notangle, noweave and noroots) and helpfully reduced the amount of magic character sequences to pretty much just <<, >> and @, and in doing so brought the wonders of literate programming within my reach.
While using the L Y X editor for LaTeX editing I had various troubles with the noweb tools, some of which were my fault, some of which were noweb's fault and some of which were L Y X's fault.
Noweb generally brought literate programming to the masses through removing some of the complexity of the original literate programming, but this would be of no advantage to me if the L Y X / LaTeX combination brought more complications in their place.
Fangle was thus born (originally called Newfangle) as an awk replacement for notangle, adding some important features, like better integration with L Y X and LaTeX (and later TeXmacs), multiple output format conversions, and fixing notangle bugs like indentation when using -L for line numbers.
Significantly, fangle is just one program which replaces various programs in Noweb. Noweave is done away with and implemented directly as LaTeX macros, and noroots is implemented as a function of the untangler fangle.
Fangle is written in awk for portability reasons, awk being available for most platforms. A Python version2. hasn't anyone implemented awk in python yet?  ^2 was considered for the benefit of L Y X but a scheme version for TeXmacs will probably materialise first; as TeXmacs macro capabilities help make edit-time and format-time rendering of fangle chunks simple enough for my weak brain.
As an extension to many literate-programming styles, Fangle permits code chunks to take parameters and thus operate somewhat like C pre-processor macros, or like C++ templates. Name parameters (or even local variables in the callers scope) are anticipated, as parameterized chunks — useful though they are — are hard to comprehend in the literate document.
License 
Fangle is licensed under the GPL 3 (or later).
This doesn't mean that sources generated by fangle must be licensed under the GPL 3.
This doesn't mean that you can't use or distribute fangle with sources of an incompatible license, but it means you must make the source of fangle available too.
As fangle is currently written in awk, an interpreted language, this should not be too hard.

4a <gpl3-copyright[1](), lang=text> ≡ 
      ________________________________________________________________________
  1  | fangle - fully featured notangle replacement in awk
  2  | 
  3  | Copyright (C) 2009-2010 Sam Liddicott <sam@liddicott.com>
  4  | 
  5  | This program is free software: you can redistribute it and/or modify
  6  | it under the terms of the GNU General Public License as published by
  7  | the Free Software Foundation, either version 3 of the License, or
  8  | (at your option) any later version.
  9  | 
  10  | This program is distributed in the hope that it will be useful,
  11  | but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13  | GNU General Public License for more details.
  14  | 
  15  | You should have received a copy of the GNU General Public License
  16  | along with this program.  If not, see <http://www.gnu.org/licenses/>.
     |________________________________________________________________________


Table of contents
Introduction   3
License   4
I Using Fangle   9
1 Introduction to Literate Programming   11
2 Running Fangle   13
2.1 Listing roots   13
2.2 Extracting roots   13
2.3 Formatting the document   13
3 Using Fangle with L^ A T_ E X   15
4 Using Fangle with L Y X   17
4.1 Installing the L Y X module   17
4.2 Obtaining a decent mono font   17
4.2.1 txfonts   17
4.2.2 ams pmb   17
4.2.3 Luximono   17
4.3 Formatting your Lyx document   18
4.3.1 Customising the listing appearance   18
4.3.2 Global customisations   18
4.4 Configuring the build script   19
4.4.1 ...   19
5 Using Fangle with T_ E X_( M A CS)   21
6 Fangle with Makefiles   23
6.1 A word about makefiles formats   23
6.2 Extracting Sources   23
6.2.1 Converting from L Y X to L^ A T_ E X   24
6.2.2 Converting from T_ E X_( M A CS)   24
6.3 Extracting Program Source   25
6.4 Extracting Source Files   25
6.5 Extracting Documentation   27
6.5.1 Formatting T_ E X   28
6.5.1.1 Running pdflatex   28
6.5.2 Formatting T_ E X_( M A CS)   28
6.5.3 Building the Documentation as a Whole   28
6.6 Other helpers   29
6.7 Boot-strapping the extraction   29
6.8 Incorporating Makefile.inc into existing projects   30
Example   30
II Source Code   33
7 Fangle awk source code   35
7.1 AWK tricks   35
7.2 Catching errors   36
8 T_ E X_( M A CS) args   37
9 L^ A T_ E X and lstlistings   39
9.1 Additional lstlstings parameters   39
9.2 Parsing chunk arguments   41
9.3 Expanding parameters in the text   42
10 Language Modes & Quoting   45
10.1 Modes to keep code together   45
10.2 Modes affect included chunks   45
10.3 Modes operation   46
10.4 Quoting scenarios   47
10.4.1 Direct quoting   47
10.5 Language Mode Definitions   47
10.5.1 Backslash   48
10.5.2 Strings   48
10.5.3 Parentheses, Braces and Brackets   49
10.5.4 Customizing Standard Modes   50
10.5.5 Comments   50
10.5.6 Regex   51
10.5.7 Perl   52
10.5.8 sh   52
10.6 Some tests   52
10.7 A non-recursive mode tracker   53
10.7.1 Constructor   53
10.7.2 Management   53
10.7.3 Tracker   55
10.7.3.1 One happy chunk   57
10.7.3.2 Tests   57
10.8 Escaping and Quoting   58
11 Recognizing Chunks   61
11.1 Chunk start   61
11.1.1 T_ E X_( M A CS)   61
11.1.2 lstlistings   62
11.2 Chunk Body   63
11.2.1 T_ E X_( M A CS)   63
11.2.2 Noweb   64
11.3 Chunk end   64
11.3.1 lstlistings   64
11.3.2 noweb   65
11.4 Chunk contents   65
11.4.1 lstlistings   66
12 Processing Options   69
13 Generating the Output   71
13.1 Assembling the Chunks   72
13.1.1 Chunk Parts   72
14 Storing Chunks   77
15 getopt   79
16 Fangle LaTeX source code   83
16.1 fangle module   83
16.1.1 The Chunk style   83
16.1.2 The chunkref style   84
16.2 Latex Macros   84
16.2.1 The chunk command   85
16.2.1.1 Chunk parameters   86
16.2.2 The noweb styled caption   86
16.2.3 The chunk counter   86
16.2.4 Cross references   89
16.2.5 The end   90
17 Extracting fangle   91
17.1 Extracting from Lyx   91
17.2 Extracting documentation   91
17.3 Extracting from the command line   92
17.4 Testing   93
III Tests   95
18 Chunk Parameters   97
18.1 L Y X   97
18.2 T_ E X_( M A CS)   97
19 Compile-log-lyx   99
Part I  Using Fangle 
Chapter 1Introduction to Literate Programming
Todo: Should really follow on from a part-0 explanation of what literate programming is.
Chapter 2Running Fangle
Fangle is a replacement for noweb, which consists of notangle, noroots and noweave.
Like notangle and noroots, fangle can read multiple named files, or from stdin.
2.1 Listing roots 
The -r option causes fangle to behave like noroots.
fangle -r filename.tex
will print out the fangle roots of a tex file. 
Unlike the noroots command, the printed roots are not enclosed in angle brackets e.g. <<name>>, unless at least one of the roots is defined using the notangle notation <<name>>=.
Also, unlike noroots, it prints out all roots --- not just those that are not used elsewhere. I find that a root not being used doesn't make it particularly top level — and so-called top level roots could also be included in another root as well. 
My convention is that top level roots to be extracted begin with ./ and have the form of a filename.
Makefile.inc, discussed in 6, can automatically extract all such sources prefixed with ./
2.2 Extracting roots 
notangle's -R and -L options are supported.
If you are using L Y X or LaTeX, the standard way to extract a file would be:
fangle -R./Makefile.inc fangle.tex > ./Makefile.inc
If you are using TeXmacs, the standard way to extract a file would similarly be:
fangle -R./Makefile.inc fangle.txt > ./Makefile.inc
TeXmacs users would obtain the text file with a verbatim export from TeXmacs which can be done on the command line with texmacs -s -c fangle.tm fangle.txt -q
Unlike the noroots command, the -L option to generate C pre-preocessor #file style line-number directives,does not break indenting of the generated file..
Also, thanks to mode tracking (described in 10) the -L option does not interrupt (and break) multi-line C macros either.
This does mean that sometimes the compiler might calculate the source line wrongly when generating error messages in such cases, but there isn't any other way around if multi-line macros include other chunks.
Future releases will include a mapping file so that line/character references from the C compiler can be converted to the correct part of the source document.
2.3 Formatting the document 
The noweave replacement built into the editing and formatting environment for TeXmacs, L Y X (which uses LaTeX), and even for raw LaTeX.
Use of fangle with TeXmacs, L Y X and LaTeX are explained the the next few chapters.
Chapter 3Using Fangle with LaTeX
Because the noweave replacement is impemented in LaTeX, there is no processing stage required before running the LaTeX command. Of course, LaTeX may need running two or more times, so that the code chunk references can be fully calculated.
The formatting is managed by a set of macros shown in 16, and can be included with:
\usepackage{fangle.sty}
Norman Ramsay's origial noweb.sty package is currently required as it is used for formatting the code chunk captions.
The listings.sty package is required, and is used for formatting the code chunks and syntax highlighting.
The xargs.sty package is also required, and makes writing LaTeX macro so much more pleasant.
To do: Add examples of use of Macros

Chapter 4Using Fangle with L Y X
L Y X uses the same LaTeX macros shown in 16 as part of a L Y X module file fangle.module, which automatically includes the macros in the document pre-amble provided that the fangle L Y X module is used in the document.
4.1 Installing the L Y X module 
Copy fangle.module to your L Y X layouts directory, which for unix users will be ~/.lyx/layouts
In order to make the new literate styles availalble, you will need to reconfigure L Y X by clicking Tools->Reconfigure, and then re-start L Y X.
4.2 Obtaining a decent mono font 
The syntax high-lighting features of lstlistings makes use of bold; however a mono-space tt font is used to typeset the listings. Obtaining a bold tt font can be impossibly difficult and amazingly easy. I spent many hours at it, following complicated instructions from those who had spend many hours over it, and was finally delivered the simple solution on the lyx mailing list.
4.2.1 txfonts 
The simple way was to add this to my preamble:
\usepackage{txfonts}
\renewcommand{\ttdefault}{txtt}

4.2.2 ams pmb 
The next simplest way was to use ams poor-mans-bold, by adding this to the pre-amble:
\usepackage{amsbsy}
%\renewcommand{\ttdefault}{txtt}
%somehow make \pmb be the command for bold, forgot how, sorry, above line not work
It works, but looks wretched on the dvi viewer.
4.2.3 Luximono 
The lstlistings documention suggests using Luximono.
Luximono was installed according to the instructions in Ubuntu Forums thread 11591811. http://ubuntuforums.org/showthread.php?t=1159181  ^1 with tips from miknight2. http://miknight.blogspot.com/2005/11/how-to-install-luxi-mono-font-in.html  ^2 stating that sudo updmap --enable MixedMap ul9.map is required. It looks fine in PDF and PS view but still looks rotten in dvi view.
4.3 Formatting your Lyx document 
It is not necessary to base your literate document on any of the original L Y X literate classes; so select a regular class for your document type.
Add the new module Fangle Literate Listings and also Logical Markup which is very useful.
In the drop-down style listbox you should notice a new style defined, called Chunk.
When you wish to insert a literate chunk, you enter it's plain name in the Chunk style, instead of the old noweb method that uses <<name>>= type tags. In the line (or paragraph) following the chunk name, you insert a listing with: Insert->Program Listing.
Inside the white listing box you can type (or paste using shift+ctrl+V) your listing. There is no need to use ctrl+enter at the end of lines as with some older L Y X literate techniques --- just press enter as normal.
4.3.1 Customising the listing appearance 
The code is formatted using the lstlistings package. The chunk style doesn't just define the chunk name, but can also define any other chunk options supported by the lstlistings package \lstset command. In fact, what you type in the chunk style is raw latex. If you want to set the chunk language without having to right-click the listing, just add ,lanuage=C after the chunk name. (Currently the language will affect all subsequent listings, so you may need to specify ,language= quite a lot).
To do: so fix the bug

Of course you can do this by editing the listings box advanced properties by right-clicking on the listings box, but that takes longer, and you can't see at-a-glance what the advanced settings are while editing the document; also advanced settings apply only to that box --- the chunk settings apply through the rest of the document3. It ought to apply only to subsequent chunks of the same name. I'll fix that later  ^3.
To do: So make sure they only apply to chunks of that name

4.3.2 Global customisations 
As lstlistings is used to set the code chunks, it's \lstset command can be used in the pre-amble to set some document wide settings.
If your source has many words with long sequences of capital letters, then columns=fullflexible may be a good idea, or the capital letters will get crowded. (I think lstlistings ought to use a slightly smaller font for captial letters so that they still fit).
The font family \ttfamily looks more normal for code, but has no bold (an alternate typewriter font is used). 
With \ttfamily, I must also specify columns=fullflexible or the wrong letter spacing is used.
In my LaTeX pre-amble I usually specialise my code format with:

19a <document-preamble[1](), lang=tex> ≡ 
      ________________________________________________________________________
  1  | \lstset{
  2  | numbers=left, stepnumber=1, numbersep=5pt,
  3  | breaklines=false,
  4  | basicstyle=\footnotesize\ttfamily,
  5  | numberstyle=\tiny,
  6  | language=C,
  7  | columns=fullflexible,
  8  | numberfirstline=true
  9  | }
     |________________________________________________________________________



4.4 Configuring the build script 
You can invoke code extraction and building from the L Y X menu option Document->Build Program.
First, make sure you don't have a conversion defined for Lyx->Program
From the menu Tools->Preferences, add a conversion from Latex(Plain)->Program as:
set -x ; fangle -Rlyx-build $$i | 
  env LYX_b=$$b LYX_i=$$i LYX_o=$$o LYX_p=$$p LYX_r=$$r bash
(But don't cut-n-paste it from this document or you may be be pasting a multi-line string which will break your lyx preferences file). 
I hope that one day, L Y X will set these into the environment when calling the build script.
You may also want to consider adding options to this conversion...
parselog=/usr/share/lyx/scripts/listerrors
...but if you do you will lose your stderr4. There is some bash plumbing to get a copy of stderr but this footnote is too small  ^4.
Now, a shell script chunk called lyx-build will be extracted and run whenever you choose the Document->Build Program menu item.
This document was originally managed using L Y X and lyx-build script for this document is shown here for historical reference. 
lyx -e latex fangle.lyx && \
  fangle fangle.lyx > ./autoboot
This looks simple enough, but as mentioned, fangle has to be had from somewhere before it can be extracted.
4.4.1 ... 
When the lyx-build chunk is executed, the current directory will be a temporary directory, and LYX_SOURCE will refer to the tex file in this temporary directory. This is unfortunate as our makefile wants to run from the project directory where the Lyx file is kept.
We can extract the project directory from $$r, and derive the probable Lyx filename from the noweb file that Lyx generated.

19b <lyx-build-helper[1](), lang=sh> ≡  91b⊳
      ________________________________________________________________________
  1  | PROJECT_DIR="$LYX_r"
  2  | LYX_SRC="$PROJECT_DIR/${LYX_i%.tex}.lyx"
  3  | TEX_DIR="$LYX_p"
  4  | TEX_SRC="$TEX_DIR/$LYX_i"
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
And then we can define a lyx-build fragment similar to the autoboot fragment

20a <lyx-build[1](), lang=sh> ≡  91a⊳
      ________________________________________________________________________
  1  | #! /bin/sh
  2  | «lyx-build-helper 19b»
  3  | cd $PROJECT_DIR || exit 1
  4  | 
  5  | #/usr/bin/fangle -filter ./notanglefix-filter \
  6  | #  -R./Makefile.inc "../../noweb-lyx/noweb-lyx3.lyx" \
  7  | #  | sed '/NOWEB_SOURCE=/s/=.*/=samba4-dfs.lyx/' \
  8  | #  > ./Makefile.inc
  9  | #
  10  | #make -f ./Makefile.inc fangle_sources
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

Chapter 5Using Fangle with TeXmacs
To do: Write this chapter

Chapter 6Fangle with Makefiles
Here we describe a Makefile.inc that you can include in your own Makefiles, or glue as a recursive make to other projects.
Makefile.inc will cope with extracting all the other source files from this or any specified literate document and keeping them up to date. 
It may also be included by a Makefile or Makefile.am defined in a literate document to automatically deal with the extraction of source files and documents during normal builds.
Thus, if Makefile.inc is included into a main project makefile it add rules for the source files, capable of extracting the source files from the literate document.
6.1 A word about makefiles formats 
Whitespace formatting is very important in a Makefile. The first character of each action line must be a TAB. 
target: pre-requisite
↦action
↦action
This requires that the literate programming environment have the ability to represent a TAB character in a way that fangle will generate an actual TAB character.
We also adopt a convention that code chunks whose names beginning with ./ should always be automatically extracted from the document. Code chunks whose names do not begin with ./ are for internal reference. Such chunks may be extracted directly, but will not be automatically extracted by this Makefile.
6.2 Extracting Sources 
Our makefile has two parts; variables must be defined before the targets that use them.
As we progress through this chapter, explaining concepts, we will be adding lines to <Makefile.inc-vars 23b> and <Makefile.inc-targets 24c> which are included in <./Makefile.inc 23a> below.

23a <./Makefile.inc[1](), lang=make> ≡ 
      ________________________________________________________________________
  1  | «Makefile.inc-vars 23b»
  2  | «Makefile.inc-default-targets 28a»
  3  | «Makefile.inc-targets 24c»
     |________________________________________________________________________


We first define a placeholder for the tool fangle in case it cannot be found in the path.

23b <Makefile.inc-vars[1](), lang=> ≡  24a⊳
      ________________________________________________________________________
  1  | FANGLE=fangle
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also define a placeholder for LITERATE_SOURCE to hold the name of this document. This will normally be passed on the command line.

24a <Makefile.inc-vars[2]() ⇑23b, lang=> +≡ ⊲23b 24b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  2  | LITERATE_SOURCE=
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Fangle cannot process L Y X or TeXmacs documents directly, so the first stage is to convert these to more suitable text based formats1. L Y X and TeXmacs formats are text-based, but not suitable for fangle  ^1.
6.2.1 Converting from L Y X to LaTeX 
The first stage will always be to convert the L Y X file to a LaTeX file. Fangle must run on a TeX file because the L Y X command server-goto-file-line2. The Lyx command server-goto-file-line is used to position the Lyx cursor at the compiler errors.  ^2 requries that the line number provided be a line of the TeX file and always maps this the line in the L Y X docment. We use server-goto-file-line when moving the cursor to error lines during compile failures.
The command lyx -e literate fangle.lyx will produce fangle.tex, a TeX file; so we define a make target to be the same as the L Y X file but with the .tex extension.
The EXTRA_DIST is for automake support so that the TeX files will automaticaly be distributed with the source, to help those who don't have L Y X installed.

24b <Makefile.inc-vars[3]() ⇑23b, lang=> +≡ ▵24a 24d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  3  | LYX_SOURCE=$(LITERATE_SOURCE) # but only the .lyx files
  4  | TEX_SOURCE=$(LYX_SOURCE:.lyx=.tex)
  5  | EXTRA_DIST+=$(TEX_SOURCE)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then specify that the TeX source is to be generated from the L Y X source.

24c <Makefile.inc-targets[1](), lang=> ≡  25a⊳
      ________________________________________________________________________
  1  | .SUFFIXES: .tex .lyx
  2  | .lyx.tex:
  3  | ↦lyx -e latex $<
  4  | clean_tex:
  5  | ↦rm -f -- $(TEX_SOURCE)
  6  | clean: clean_tex
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.2.2 Converting from TeXmacs 
Fangle cannot process TeXmacs files directly3. but this is planned when TeXmacs uses xml as it's native format  ^3, but must first convert them to text files.
The command texmacs -c fangle.tm fangle.txt -q will produce fangle.txt, a text file; so we define a make target to be the same as the TeXmacs file but with the .txt extension.
The EXTRA_DIST is for automake support so that the TeX files will automaticaly be distributed with the source, to help those who don't have L Y X installed.

24d <Makefile.inc-vars[4]() ⇑23b, lang=> +≡ ▵24b 25b⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  6  | TEXMACS_SOURCE=$(LITERATE_SOURCE) # but only the .tm files
  7  | TXT_SOURCE=$(LITERATE_SOURCE:.tm=.txt)
  8  | EXTRA_DIST+=$(TXT_SOURCE)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
To do: Add loop around each $< so multiple targets can be specified


25a <Makefile.inc-targets[2]() ⇑24c, lang=> +≡ ⊲24c 25d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  7  | .SUFFIXES: .txt .tm
  8  | .tm.txt:
  9  | ↦texmacs -s -c $< $@ -q
  10  | .PHONEY: clean_txt
  11  | clean_txt:
  12  | ↦rm -f -- $(TXT_SOURCE)
  13  | clean: clean_txt
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.3 Extracting Program Source 
The program source is extracted using fangle, which is designed to operate on text or a LaTeX documents4. LaTeX documents are just slightly special text documents  ^4.

25b <Makefile.inc-vars[5]() ⇑23b, lang=> +≡ ⊲24d 25c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  9  | FANGLE_SOURCE=$(TXT_SOURCE)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The literate document can result in any number of source files, but not all of these will be changed each time the document is updated. We certainly don't want to update the timestamps of these files and cause the whole source tree to be recompiled just because the literate explanation was revised. We use CPIF from the Noweb tools to avoid updating the file if the content has not changed, but should probably write our own.
However, if a source file is not updated, then the fangle file will always have a newer time-stamp and the makefile would always re-attempt to extact a newer source file which would be a waste of time.
Because of this, we use a stamp file which is always updated each time the sources are fully extracted from the LaTeX document. If the stamp file is newer than the document, then we can avoid an attempt to re-extract any of the sources. Because this stamp file is only updated when extraction is complete, it is safe for the user to interrupt the build-process mid-extraction.
We use echo rather than touch to update the stamp file beause the touch command does not work very well over an sshfs mount  that I was using.

25c <Makefile.inc-vars[6]() ⇑23b, lang=> +≡ ▵25b 26a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  10  | FANGLE_SOURCE_STAMP=$(FANGLE_SOURCE).stamp
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

25d <Makefile.inc-targets[3]() ⇑24c, lang=> +≡ ▵25a 26b⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  14  | $(FANGLE_SOURCE_STAMP): $(FANGLE_SOURCE) \
  15  | ↦                $(FANGLE_SOURCES) ; \
  16  | ↦echo -n > $(FANGLE_SOURCE_STAMP)
  17  | clean_stamp:
  18  | ↦rm -f $(FANGLE_SOURCE_STAMP)
  19  | clean: clean_stamp
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.4 Extracting Source Files 
We compute FANGLE_SOURCES to hold the names of all the source files defined in the document. We compute this only once, by means of := in assignent. The sed deletes the any << and >> which may surround the roots names (for compatibility with Noweb's noroots command).
As we use chunk names beginning with ./ to denote top level fragments that should be extracted, we filter out all fragments that do not begin with ./
Note 1. FANGLE_PREFIX is set to ./ by default, but whatever it may be overridden to, the prefix is replaced by a literal ./ before extraction so that files will be extracted in the current directory whatever the prefix. This helps namespace or sub-project prefixes like documents: for chunks like documents:docbook/intro.xml 
To do: This doesn't work though, because it loses the full name and doesn't know what to extact!


26a <Makefile.inc-vars[7]() ⇑23b, lang=> +≡ ⊲25c 26e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  11  | FANGLE_PREFIX:=\.\/
  12  | FANGLE_SOURCES:=$(shell \
  13  |   $(FANGLE) -r $(FANGLE_SOURCE) |\
  14  |   sed -e 's/^[<][<]//;s/[>][>]$$//;/^$(FANGLE_PREFIX)/!d' \
  15  |       -e 's/^$(FANGLE_PREFIX)/\.\//' )
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The target below, echo_fangle_sources is a helpful debugging target and shows the names of the files that would be extracted.

26b <Makefile.inc-targets[4]() ⇑24c, lang=> +≡ ⊲25d 26c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  20  | .PHONY: echo_fangle_sources
  21  | echo_fangle_sources: ; @echo $(FANGLE_SOURCES)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We define a convenient target called fangle_sources so that make -f fangle_sources will re-extract the source if the literate document has been updated. 

26c <Makefile.inc-targets[5]() ⇑24c, lang=> +≡ ▵26b 26d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  22  | .PHONY: fangle_sources
  23  | fangle_sources: $(FANGLE_SOURCE_STAMP)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
And also a convenient target to remove extracted sources.

26d <Makefile.inc-targets[6]() ⇑24c, lang=> +≡ ▵26c 27e⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  24  | .PHONY: clean_fangle_sources
  25  | clean_fangle_sources: ; \
  26  |         rm -f -- $(FANGLE_SOURCE_STAMP) $(FANGLE_SOURCES)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We now look at the extraction of the source files.
This makefile macro if_extension takes 4 arguments: the filename $(1), some extensions to match $(2) and a shell command to return if the filename does match the exensions $(3), and a shell command to return if it does not match the extensions $(4).

26e <Makefile.inc-vars[8]() ⇑23b, lang=> +≡ ▵26a 26f▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  16  | if_extension=$(if $(findstring $(suffix $(1)),$(2)),$(3),$(4))
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
For some source files like C files, we want to output the line number and filename of the original LaTeX document from which the source came5. I plan to replace this option with a separate mapping file so as not to pollute the generated source, and also to allow a code pretty-printing reformatter like indent be able to re-format the file and adjust for changes through comparing the character streams.  ^5.
To make this easier we define the file extensions for which we want to do this.

26f <Makefile.inc-vars[9]() ⇑23b, lang=> +≡ ▵26e 27a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  17  | C_EXTENSIONS=.c .h
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We can then use the if_extensions macro to define a macro which expands out to the -L option if fangle is being invoked in a C source file, so that C compile errors will refer to the line number in the TeX document. 

27a <Makefile.inc-vars[10]() ⇑23b, lang=> +≡ ⊲26f 27b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  18  | TABS=8
  19  | nf_line=-L -T$(TABS)
  20  | fangle=$(FANGLE) $(call if_extension,$(2),$(C_EXTENSIONS),$(nf_line)) -R"$(2)" $(1)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We can use a similar trick to define an indent macro which takes just the filename as an argument and can return a pipeline stage calling the indent command. Indent can be turned off with make fangle_sources indent=

27b <Makefile.inc-vars[11]() ⇑23b, lang=> +≡ ▵27a 27c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  21  | indent_options=-npro -kr -i8 -ts8 -sob -l80 -ss -ncs
  22  | indent=$(call if_extension,$(1),$(C_EXTENSIONS), | indent $(indent_options))
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We now define the pattern for extracting a file. The files are written using noweb's cpif so that the file timestamp will not be touched if the contents haven't changed. This avoids the need to rebuild the entire project because of a typographical change in the documentation, or if none or a few C source files have changed.

27c <Makefile.inc-vars[12]() ⇑23b, lang=> +≡ ▵27b 27d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  23  | fangle_extract=@mkdir -p $(dir $(1)) && \
  24  |   $(call fangle,$(2),$(1)) > "$(1).tmp" && \
  25  |   cat "$(1).tmp" $(indent) | cpif "$(1)" \
  26  |   && rm -f -- "$(1).tmp" || \
  27  |   (echo error fangling $(1) from $(2) ; exit 1)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We define a target which will extract or update all sources. To do this we first defined a makefile template that can do this for any source file in the LaTeX document.

27d <Makefile.inc-vars[13]() ⇑23b, lang=> +≡ ▵27c 28b⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  28  | define FANGLE_template
  29  |   $(1): $(2)
  30  | ↦$$(call fangle_extract,$(1),$(2))
  31  |   FANGLE_TARGETS+=$(1)
  32  | endef
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then enumerate the discovered FANGLE_SOURCES to generate a makefile rule for each one using the makefile template we defined above.

27e <Makefile.inc-targets[7]() ⇑24c, lang=> +≡ ⊲26d 27f▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  27  | $(foreach source,$(FANGLE_SOURCES),\
  28  |   $(eval $(call FANGLE_template,$(source),$(FANGLE_SOURCE))) \
  29  | )
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
These will all be built with FANGLE_SOURCE_STAMP.
We also remove the generated sources on a make distclean.

27f <Makefile.inc-targets[8]() ⇑24c, lang=> +≡ ▵27e 28c⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  30  | _distclean: clean_fangle_sources
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.5 Extracting Documentation 
We then identify the intermediate stages of the documentation and their build and clean targets.

28a <Makefile.inc-default-targets[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | .PHONEY : clean_pdf
     |________________________________________________________________________


6.5.1 Formatting TeX 
6.5.1.1 Running pdflatex 
We produce a pdf file from the tex file.

28b <Makefile.inc-vars[14]() ⇑23b, lang=> +≡ ⊲27d 28d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  33  | FANGLE_PDF+=$(TEX_SOURCE:.tex=.pdf)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We run pdflatex twice to be sure that the contents and aux files are up to date. We certainly are required to run pdflatex at least twice if these files do not exist.

28c <Makefile.inc-targets[9]() ⇑24c, lang=> +≡ ⊲27f 28e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  31  | .SUFFIXES: .tex .pdf
  32  | .tex.pdf:
  33  | ↦pdflatex $< && pdflatex $<
  34  | 
  35  | clean_pdf_tex:
  36  | ↦rm -f -- $(FANGLE_PDF) $(TEX_SOURCE:.tex=.toc) \
  37  | ↦  $(TEX_SOURCE:.tex=.log) $(TEX_SOURCE:.tex=.aux)
  38  | clean_pdf: clean_pdf_tex
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.5.2 Formatting TeXmacs 
TeXmacs can produce a PDF file directly.

28d <Makefile.inc-vars[15]() ⇑23b, lang=> +≡ ▵28b 28f▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  34  | FANGLE_PDF+=$(LITERATE_SOURCE:.tm=.pdf)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
To do: Outputting the PDF may not be enough to update the links and page references. I think
we need to update twice, generate a pdf, update twice mode and generate a new PDF.
Basically the PDF export of TeXmacs is pretty rotten and doesn't work properly from the CLI


28e <Makefile.inc-targets[10]() ⇑24c, lang=> +≡ ▵28c 29a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  39  | .SUFFIXES: .tm .pdf
  40  | .tm.pdf:
  41  | ↦texmacs -s -c $< $@ -q
  42  | 
  43  | clean_pdf_texmacs:
  44  | ↦rm -f -- $(FANGLE_PDF)
  45  | clean_pdf: clean_pdf_texmacs
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
6.5.3 Building the Documentation as a Whole 
Currently we only build pdf as a final format, but FANGLE_DOCS may later hold other output formats.

28f <Makefile.inc-vars[16]() ⇑23b, lang=> +≡ ▵28d
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  35  | FANGLE_DOCS=$(FANGLE_PDF)
     |________________________________________________________________________


We also define fangle_docs as a convenient phony target.

29a <Makefile.inc-targets[11]() ⇑24c, lang=> +≡ ⊲28e 29b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  46  | .PHONY: fangle_docs
  47  | fangle_docs: $(FANGLE_DOCS)
  48  | docs: fangle_docs
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
And define a convenient clean_fangle_docs which we add to the regular clean target

29b <Makefile.inc-targets[12]() ⇑24c, lang=> +≡ ▵29a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  49  | .PHONEY: clean_fangle_docs
  50  | clean_fangle_docs: clean_tex clean_pdf
  51  | clean: clean_fangle_docs
  52  | 
  53  | distclean_fangle_docs: clean_tex clean_fangle_docs
  54  | distclean: clean distclean_fangle_docs
     |________________________________________________________________________


6.6 Other helpers 
If Makefile.inc is included into Makefile, then extracted files can be updated with this command:
make fangle_sources
otherwise, with:
make -f Makefile.inc fangle_sources
6.7 Boot-strapping the extraction 
As well as having the makefile extract or update the source files as part of it's operation, it also seems convenient to have the makefile re-extracted itself from this document.
It would also be convenient to have the code that extracts the makefile from this document to also be part of this document, however we have to start somewhere and this unfortunately requires us to type at least a few words by hand to start things off.
Therefore we will have a minimal root fragment, which, when extracted, can cope with extracting the rest of the source. This shell script fragment can do that. It's name is * — out of regard for Noweb, but when extracted might better be called autoupdate.
To do: De-lyxify


29c <*[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | #! /bin/sh
  2  | 
  3  | MAKE_SRC="${1:-${NW_LYX:-../../noweb-lyx/noweb-lyx3.lyx}}"
  4  | MAKE_SRC=‘dirname "$MAKE_SRC"‘/‘basename "$MAKE_SRC" .lyx‘
  5  | NOWEB_SRC="${2:-${NOWEB_SRC:-$MAKE_SRC.lyx}}"
  6  | lyx -e latex $MAKE_SRC
  7  | 
  8  | fangle -R./Makefile.inc ${MAKE_SRC}.tex \
  9  |   | sed "/FANGLE_SOURCE=/s/^/#/;T;aNOWEB_SOURCE=$FANGLE_SRC" \
  10  |   | cpif ./Makefile.inc
  11  | 
  12  | make -f ./Makefile.inc fangle_sources
     |________________________________________________________________________


The general Makefile can be invoked with ./autoboot and can also be included into any automake file to automatically re-generate the source files.
The autoboot can be extracted with this command:
lyx -e latex fangle.lyx && \
  fangle fangle.lyx > ./autoboot
This looks simple enough, but as mentioned, fangle has to be had from somewhere before it can be extracted.
On a unix system this will extract fangle.module and the fangle awk script, and run some basic tests. 
To do: cross-ref to test chapter when it is a chapter all on its own

6.8 Incorporating Makefile.inc into existing projects 
If you are writing a literate module of an existing non-literate program you may find it easier to use a slight recursive make instead of directly including Makefile.inc in the projects makefile. 
This way there is less chance of definitions in Makefile.inc interfering with definitions in the main makefile, or with definitions in other Makefile.inc from other literate modules of the same project.
To do this we add some glue to the project makefile that invokes Makefile.inc in the right way. The glue works by adding a .PHONY target to call the recursive make, and adding this target as an additional pre-requisite to the existing targets.
Example Sub-module of existing system
In this example, we are building module.so as a literate module of a larger project.
We will show the sort glue that can be inserted into the projects Makefile — or more likely — a regular Makefile included in or invoked by the projects Makefile.

30a <makefile-glue[1](), lang=> ≡  30b▿
      ________________________________________________________________________
  1  | module_srcdir=modules/module
  2  | MODULE_SOURCE=module.tm
  3  | MODULE_STAMP=$(MODULE_SOURCE).stamp
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The existing build system may already have a build target for module.o, but we just add another pre-requisite to that. In this case we use module.tm.stamp as a pre-requisite, the stamp file's modified time indicating when all sources were extracted6. If the projects build system does not know how to build the module from the extracted sources, then just add build actions here as normal.  ^6.

30b <makefile-glue[2]() ⇑30a, lang=make> +≡ ▵30a 30c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  4  | $(module_srcdir)/module.o: $(module_srcdir)/$(MODULE_STAMP)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The target for this new pre-requisite will be generated by a recursive make using Makefile.inc which will make sure that the source is up to date, before it is built by the main projects makefile.

30c <makefile-glue[3]() ⇑30a, lang=> +≡ ▵30b 31a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  5  | $(module_srcdir)/$(MODULE_STAMP): $(module_srcdir)/$(MODULE_SOURCE)
  6  | ↦$(MAKE) -C $(module_srcdir) -f Makefile.inc fangle_sources LITERATE_SOURCE=$(MODULE_SOURCE)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We can do similar glue for the docs, clean and distclean targets. In this example the main prject was using a double colon for these targets, so we must use the same in our glue.

31a <makefile-glue[4]() ⇑30a, lang=> +≡ ⊲30c
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  7  | docs:: docs_module
  8  | .PHONY: docs_module
  9  | docs_module:
  10  | ↦$(MAKE) -C $(module_srcdir) -f Makefile.inc docs LITERATE_SOURCE=$(MODULE_SOURCE)
  11  | 
  12  | clean:: clean_module
  13  | .PHONEY: clean_module
  14  | clean_module:
  15  | ↦$(MAKE) -C $(module_srcdir) -f Makefile.inc clean LITERATE_SOURCE=$(MODULE_SOURCE)
  16  | 
  17  | distclean:: distclean_module
  18  | .PHONY: distclean_module
  19  | distclean_module:
  20  | ↦$(MAKE) -C $(module_srcdir) -f Makefile.inc distclean LITERATE_SOURCE=$(MODULE_SOURCE)
     |________________________________________________________________________


We could do similarly for install targets to install the generated docs.
Part II  Source Code 
Chapter 7Fangle awk source code
We use the copyright notice from chapter 2.

35a <./fangle[1](), lang=awk> ≡  35b▿
      ________________________________________________________________________
  1  | #! /usr/bin/awk -f
  2  | # «gpl3-copyright 4a»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also use code from Arnold Robbins public domain getopt (1993 revision) defined in 81a, and naturally want to attribute this appropriately.

35b <./fangle[2]() ⇑35a, lang=> +≡ ▵35a 35c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  3  | # NOTE: Arnold Robbins public domain getopt for awk is also used:
  4  | «getopt.awk-header 79a»
  5  | «getopt.awk-getopt() 79c»
  6  | 
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
And include the following chunks (which are explained further on) to make up the program:

35c <./fangle[3]() ⇑35a, lang=> +≡ ▵35b 40a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  7  | «helper-functions 36d»
  8  | «mode-tracker 57b»
  9  | «parse_chunk_args 42a»
  10  | «chunk-storage-functions 77b»
  11  | «output_chunk_names() 71d»
  12  | «output_chunks() 71e»
  13  | «write_chunk() 72a»
  14  | «expand_chunk_args() 42b»
  15  | 
  16  | «begin 69d»
  17  | «recognize-chunk 61a»
  18  | «end 71c»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
7.1 AWK tricks 
The portable way to erase an array in awk is to split the empty string, so we define a fangle macro that can split an array, like this:

35d <awk-delete-array[1](ARRAY), lang=awk> ≡ 
      ________________________________________________________________________
  1  | split("", ${ARRAY});
     |________________________________________________________________________


For debugging it is sometimes convenient to be able to dump the contents of an array to stderr, and so this macro is also useful.

35e <dump-array[1](ARRAY), lang=awk> ≡ 
      ________________________________________________________________________
  1  | print "\nDump: ${ARRAY}\n--------\n" > "/dev/stderr";
  2  | for (_x in ${ARRAY}) {
  3  |   print _x "=" ${ARRAY}[_x] "\n" > "/dev/stderr";
  4  | }
  5  | print "========\n" > "/dev/stderr";
     |________________________________________________________________________


7.2 Catching errors 
Fatal errors are issued with the error function:

36a <error()[1](), lang=awk> ≡  36b▿
      ________________________________________________________________________
  1  | function error(message)
  2  | {
  3  |   print "ERROR: " FILENAME ":" FNR " " message > "/dev/stderr";
  4  |   exit 1;
  5  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
and likewise for non-fatal warnings:

36b <error()[2]() ⇑36a, lang=awk> +≡ ▵36a 36c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  6  | function warning(message)
  7  | {
  8  |   print "WARNING: " FILENAME ":" FNR " " message > "/dev/stderr";
  9  |   warnings++;
  10  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
and debug output too:

36c <error()[3]() ⇑36a, lang=awk> +≡ ▵36b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  11  | function debug_log(message)
  12  | {
  13  |   print "DEBUG: " FILENAME ":" FNR " " message > "/dev/stderr";
  14  | }
     |________________________________________________________________________


To do: append=helper-functions


36d <helper-functions[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | «error() 36a»
     |________________________________________________________________________


Chapter 8TeXmacs args
TeXmacs functions with arguments1. or function declarations with parameters  ^1 appear like this:
blah((I came, I saw, I conquered)<wide-overbrace>^(argument 1)(^K, )<wide-overbrace>^(sep.)(and then went home asd)<wide-overbrace>^(argument 3)(^K))<wide-overbrace>^(term.)_arguments
Arguments commence after the opening parenthesis. The first argument runs up till the next ^K. 
If the following character is a , then another argument follows. If the next character after the , is a space character, then it is also eaten. The fangle stylesheet emits ^K,space as separators, but the fangle untangler will forgive a missing space.
If the following character is ) then this is a terminator and there are no more arguments.

37a <constants[1](), lang=> ≡  77a⊳
      ________________________________________________________________________
  1  | ARG_SEPARATOR=sprintf("%c", 11);
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
To process the text in this fashion, we split the string on ^K


37b <get_chunk_args[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function get_texmacs_chunk_args(text, args,   a, done) {
  2  |   split(text, args, ARG_SEPARATOR);
  3  | 
  4  |   done=0
  5  |   for (a=1; (a in args); a++) if (a>1) {
  6  |     if (args[a] == "" || substr(args[a], 1, 1) == ")") done=1;
  7  |     if (done) {
  8  |       delete args[a];
  9  |       break;
  10  |     }
  11  | 
  12  |     if (substr(args[a], 1, 2) == ", ") args[a]=substr(args[a], 3);
  13  |     else if (substr(args[a], 1, 1) == ",") args[a]=substr(args[a], 2);  
  14  |   }
  15  | }
     |________________________________________________________________________


Chapter 9LaTeX and lstlistings
To do: Split LyX and TeXmacs parts

For L Y X and LaTeX, the lstlistings package is used to format the lines of code chunks. You may recal from chapter XXX that arguments to a chunk definition are pure LaTeX code. This means that fangle needs to be able to parse LaTeX a little.
LaTeX arguments to lstlistings macros are a comma seperated list of key-value pairs, and values containing commas are enclosed in { braces } (which is to be expected for LaTeX).
A sample expressions is:
name=thomas, params={a, b}, something, something-else
but we see that this is just a simpler form of this expression:
name=freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
We may consider that we need a function that can parse such LaTeX expressions and assign the values to an AWK associated array, perhaps using a recursive parser into a multi-dimensional hash1. as AWK doesn't have nested-hash support  ^1, resulting in:
key                 value
a[name]             freddie
a[foo, bar]         baz
a[foo, quux, quirk] 
a[foo, quux, a]     fleeg
a[etc]              

Yet, also, on reflection it seems that sometimes such nesting is not desirable, as the braces are also used to delimit values that contain commas --- we may consider that
name={williamson, freddie}
should assign williamson, freddie to name.
In fact we are not so interested in the detail so as to be bothered by this, which turns out to be a good thing for two reasons. Firstly TeX has a malleable parser with no strict syntax, and secondly whether or not williamson and freddie should count as two items will be context dependant anyway.
We need to parse this latex for only one reason; which is that we are extending lstlistings to add some additional arguments which will be used to express chunk parameters and other chunk options.
9.1 Additional lstlstings parameters 
Further on we define a \Chunk LaTeX macro whose arguments will consist of a the chunk name, optionally followed by a comma and then a comma separated list of arguments. In fact we will just need to prefix name= to the arguments to in order to create valid lstlistings arguments. 
There will be other arguments supported too; 
params.As an extension to many literate-programming styles, fangle permits code chunks to take parameters and thus operate somewhat like C pre-processor macros, or like C++ templates. Chunk parameters are declared with a chunk argument called params, which holds a semi-colon separated list of parameters, like this:
achunk,language=C,params=name;address
addto.a named chunk that this chunk is to be included into. This saves the effort of having to declare another listing of the named chunk merely to include this one. 
Function get_chunk_args() will accept two paramters, text being the text to parse, and values being an array to receive the parsed values as described above. The optional parameter path is used during recursion to build up the multi-dimensional array path.

40a <./fangle[4]() ⇑35a, lang=> +≡ ⊲35c
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  19  | «get_chunk_args() 40b»
     |________________________________________________________________________



40b <get_chunk_args()[1](), lang=> ≡  40c▿
      ________________________________________________________________________
  1  | function get_tex_chunk_args(text, values,
  2  |   # optional parameters
  3  |   path, # hierarchical precursors
  4  |   # local vars
  5  |   a, name)
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The strategy is to parse the name, and then look for a value. If the value begins with a brace {, then we recurse and consume as much of the text as necessary, returning the remaining text when we encounter a leading close-brace }. This being the strategy --- and executed in a loop --- we realise that we must first look for the closing brace (perhaps preceded by white space) in order to terminate the recursion, and returning remaining text.

40c <get_chunk_args()[2]() ⇑40b, lang=> +≡ ▵40b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  6  | {
  7  |   split("", values);
  8  |   while(length(text)) {
  9  |     if (match(text, "^ *}(.*)", a)) {
  10  |       return a[1];
  11  |     }
  12  |     «parse-chunk-args 40d»
  13  |   }
  14  |   return text;
  15  | }
     |________________________________________________________________________


We can see that the text could be inspected with this regex:

40d <parse-chunk-args[1](), lang=> ≡  41a⊳
      ________________________________________________________________________
  1  | if (! match(text, " *([^,=]*[^,= ]) *(([,=]) *(([^,}]*) *,* *(.*))|)$", a)) {
  2  |   return text;
  3  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
and that a will have the following values:
a[n] assigned text
1    freddie
2    =freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
3    =
4    freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
5    freddie
6    , foo={bar=baz, quux={quirk, a=fleeg}}, etc

a[3] will be either = or , and signify whether the option named in a[1] has a value or not (respectively).
If the option does have a value, then if the expression substr(a[4],1,1) returns a brace { it will signify that we need to recurse:

41a <parse-chunk-args[2]() ⇑40d, lang=> +≡ ⊲40d
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  4  | name=a[1];
  5  | if (a[3] == "=") {
  6  |   if (substr(a[4],1,1) == "{") {
  7  |     text = get_tex_chunk_args(substr(a[4],2), values, path name SUBSEP);
  8  |   } else {
  9  |     values[path name]=a[5];
  10  |     text = a[6];
  11  |   }
  12  | } else {
  13  |   values[path name]="";
  14  |   text = a[2];
  15  | }
     |________________________________________________________________________


We can test this function like this:

41b <gca-test.awk[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | «get_chunk_args() 40b»
  2  | BEGIN {
  3  |   SUBSEP=".";
  4  | 
  5  |   print get_tex_chunk_args("name=freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc", a);
  6  |   for (b in a) {
  7  |     print "a[" b "] => " a[b];
  8  |   }
  9  | }
     |________________________________________________________________________


which should give this output:

41c <gca-test.awk-results[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | a[foo.quux.quirk] => 
  2  | a[foo.quux.a] => fleeg
  3  | a[foo.bar] => baz
  4  | a[etc] => 
  5  | a[name] => freddie
     |________________________________________________________________________


9.2 Parsing chunk arguments 
Arguments to paramterized chunks are expressed in round brackets as a comma separated list of optional arguments. For example, a chunk that is defined with:
\Chunk{achunk, params=name ; address}
could be invoked as:
\chunkref{achunk}(John Jones, jones@example.com)
An argument list may be as simple as in \chunkref{pull}(thing, otherthing) or as complex as:
\chunkref{pull}(things[x, y], get_other_things(a, "(all)"))
--- which for all it's commas and quotes and parenthesis represents only two parameters: things[x, y] and get_other_things(a, "(all)").
If we simply split parameter list on commas, then the comma in things[x,y] would split into two seperate arguments: things[x and y]--- neither of which make sense on their own.
One way to prevent this would be by refusing to split text between matching delimiters, such as [, ], (, ), {, } and most likely also ", " and ', '. Of course this also makes it impossible to pass such mis-matched code fragments as parameters, but I think that it would be hard for readers to cope with authors who would pass such code unbalanced fragments as chunk parameters2. I know that I couldn't cope with users doing such things, and although the GPL3 license prevents me from actually forbidding anyone from trying, if they want it to work they'll have to write the code themselves and not expect any support from me.  ^2.
Unfortunately, the full set of matching delimiters may vary from language to language. In certain C++ template contexts, < and > would count as delimiters, and yet in other contexts they would not.
This puts me in the unfortunate position of having to parse-somewhat all programming languages without knowing what they are!
However, if this universal mode-tracking is possible, then parsing the arguments would be trivial. Such a mode tracker is described in chapter 10 and used here with simplicity.

42a <parse_chunk_args[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function parse_chunk_args(language, text, values, mode,
  2  |   # local vars
  3  |   c, context, rest)
  4  | {
  5  |   «new-mode-tracker(context, language, mode) 53c»
  6  |   rest = mode_tracker(context, text, values);
  7  |   # extract values
  8  |   for(c=1; c <= context[0, "values"]; c++) {
  9  |     values[c] = context[0, "values", c];
  10  |   }
  11  |   return rest;
  12  | }
     |________________________________________________________________________


9.3 Expanding parameters in the text 
Within the body of the chunk, the parameters are referred to with: ${name} and ${address}. There is a strong case that a LaTeX style notation should be used, like \param{name} which would be expressed in the listing as =<\param{name}> and be rendered as ${name}. Such notation would make me go blind, but I do intend to adopt it.
We therefore need a function expand_chunk_args which will take a block of text, a list of permitted parameters, and the arguments which must substitute for the parameters. 
Here we split the text on ${ which means that all parts except the first will begin with a parameter name which will be terminated by }. The split function will consume the literal ${ in each case.

42b <expand_chunk_args()[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function expand_chunk_args(text, params, args,  
  2  |   p, text_array, next_text, v, t, l)
  3  | {
  4  |   if (split(text, text_array, "\\${")) {
  5  |     «substitute-chunk-args 43a»
  6  |   }
  7  | 
  8  |   return text;
  9  | }
     |________________________________________________________________________


First, we produce an associative array of substitution values indexed by parameter names. This will serve as a cache, allowing us to look up the replacement values as we extract each name.

43a <substitute-chunk-args[1](), lang=> ≡  43b▿
      ________________________________________________________________________
  1  | for(p in params) {
  2  |   v[params[p]]=args[p];
  3  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We accumulate substituted text in the variable text. As the first part of the split function is the part before the delimiter --- which is ${ in our case --- this part will never contain a parameter reference, so we assign this directly to the result kept in $text.

43b <substitute-chunk-args[2]() ⇑43a, lang=> +≡ ▵43a 43c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  4  | text=text_array[1];
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then iterate over the remaining values in the array, and substitute each reference for it's argument.

43c <substitute-chunk-args[3]() ⇑43a, lang=> +≡ ▵43b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  5  | for(t=2; t in text_array; t++) {
  6  |   «substitute-chunk-arg 43d»
  7  | }
     |________________________________________________________________________


After the split on ${ a valid parameter reference will consist of valid parameter name terminated by a close-brace }. A valid character name begins with the underscore or a letter, and may contain letters, digits or underscores.
A valid looking reference that is not actually the name of a parameter will be and not substituted. This is good because there is nothing to substitute anyway, and it avoids clashes when writing code for languages where ${...} is a valid construct --- such constructs will not be interfered with unless the parameter name also matches.

43d <substitute-chunk-arg[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (match(text_array[t], "^([a-zA-Z_][a-zA-Z0-9_]*)}", l) &&
  2  |     l[1] in v) 
  3  | {
  4  |   text = text v[l[1]] substr(text_array[t], length(l[1])+2);
  5  | } else {
  6  |   text = text "${" text_array[t];
  7  | }
     |________________________________________________________________________


Chapter 10Language Modes & Quoting
lstlistings and fangle both recognize source languages, and perform some basic parsing and syntax highlighting in the rendered document1. although lstlisting supports many more languages  ^1. lstlistings can detect strings and comments within a language definition and perform suitable rendering, such as italics for comments, and visible-spaces within strings.
Fangle similarly can recognize strings, and comments, etc, within a language, so that any chunks included with \chunkref{a-chunk} or <a-chunk ?> can be suitably escape or quoted.
10.1 Modes to keep code together 
As an example, the C language has a few parse modes, which affect the interpretation of characters.
One parse mode is the string mode. The string mode is commenced by an un-escaped quotation mark " and terminated by the same. Within the string mode, only one additional mode can be commenced, it is the backslash mode \, which is always terminated by the following character.
Another mode is [ which is terminated by a ] (unless it occurs in a string).
Consider this fragment of C code:
do_something((things([x, y])<wide-overbrace>^(2. [ mode), get_other_things((a, "(all)"_(4. " mode)))<wide-overbrace>^(3. ( mode)))<wide-overbrace>^(1. ( mode)

Mode nesting prevents the close parenthesis in the quoted string (part 4) from terminating the parenthesis mode (part 3).
Each language has a set of modes, the default mode being the null mode. Each mode can lead to other modes.
10.2 Modes affect included chunks 
For instance, consider this chunk with language=perl:

?a <test:example-perl[1](), lang=perl> ≡ 
      ________________________________________________________________________
  1  | print "hello world $0\n";
     |________________________________________________________________________


If it were included in a chunk with language=sh, like this:

?b <test:example-sh[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | perl -e "«test:example-perl ?a»"
     |________________________________________________________________________


we might want fangle would to generate output like this:

?c <test:example-sh.result[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | perl -e "print \"hello world \$0\\n\";"
     |________________________________________________________________________


See that the double quote ", back-slash \ and $ have been quoted with a back-slash to protect them from shell interpretation.
If that were then included in a chunk with language=make, like this:

?d <test:example-makefile[1](), lang=make> ≡ 
      ________________________________________________________________________
  1  | target: pre-req
  2  | ↦«test:example-sh ?b»
     |________________________________________________________________________


We would need the output to look like this --- note the $$ as the single $ has been makefile-quoted with another $.

?e <test:example-makefile.result[1](), lang=make> ≡ 
      ________________________________________________________________________
  1  | target: pre-req
  2  | ↦perl -e "print \"hello world \$$0\\n\";"
     |________________________________________________________________________


10.3 Modes operation 
In order to make this work, we must define a mode-tracker supporting each language, that can detect the various quoting modes, and provide a transformation that may be applied to any included text so that included text will be interpreted correctly after any interpolation that it may be subject to at run-time.
For example, the sed transformation for text to be inserted into shell double-quoted strings would be something like:
s/\\/\\\\/g;s/$/\\$/g;s/"/\\"/g;
which would protect \ $ "
The mode tracker must also nested mode-changes, as in this shell example:
echo "hello ‘id ...‘"
↑
Any shell special characters inserted at the point marked ↑ would need to be escaped if their plain-text meaning is to be preserved, including ‘ | * among others. The set of characters that need escaping in the back-ticks ‘ is not the same as the set that need escaing in the double-quotes ". However, in shell syntax, a " at the point marked ↑ does not close the leading " and so would not need additional escaping because of the nesting of the two modes.
To do: MAYBE
Escaping need not occur if the format and mode of the included chunk matches that of the including chunk.
As each chunk is output a new mode tracker for that language is initialized in it's normal state. As text is output for that chunk the output mode is tracked. When a new chunk is included, a transformation appropriate to that mode is selected and pushed onto a stack of transformations. Any text to be output is passed through this stack of transformations.
It remains to consider if the chunk-include function should return it's generated text so that the caller can apply any transformations (and formatting), or if it should apply the stack of transformations itself.
Note that the transformed included text should have the property of not being able to change the mode in the current chunk.
To do: Note chunk parameters should probably also be transformed

10.4 Quoting scenarios 
10.4.1 Direct quoting 
He we give examples of various quoting scenarios and discuss what the expected outcome might be and how this could be obtained.

47a <test:q:1[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | echo "$(«test:q:1-inc 47b»)"
     |________________________________________________________________________



47b <test:q:1-inc[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | echo "hello"
     |________________________________________________________________________


Should this examples produce echo "$(echo "hello")" or echo "\$(echo \"hello\")" ?
This depends on what the author intended, but we must privde a way to express that intent.
We might argue that as both chunks have lang=sh the intent must have been to quote the included chunk — but consider that this might be shell script that writes shell script.
If <test:q:1-inc 47b> had lang=text then it certainly would have been right to quote it, which leads us to ask: in what ways can we reduce quoting if lang of the included chunk is compatible with the lang of the including chunk?
If we take a completely nested approach then even though $( mode might do no quoting of it's own, " mode will still do it's own quoting. We need a model where the nested $( mode will prevent " from quoting.
This leads rise to the tunneling feature. In bash, the $( gives rise to a new top-level parsing scenario, so we need to enter the null mode, and also ignore any quoting and then undo-this when the $( mode is terminated by the corresponding close ).
We shall say that tunneling is when a mode in a language ignores other modes in the same language and arrives back at an earlier null mode of the same language.
In example <test:q:1 47a> above, the nesting of modes is: null, ", $(
When mode $( is commenced, the stack of nest modes will be traversed. If the null moed can be found in the same language, without the language varying, then a tunnel will be established so that the intervening modes, " in this case, can be skipped when the modes are enumerated to quote the texted being emitted.
10.5 Language Mode Definitions 
All modes definitions are stored in a single multi-dimensional hash. The first index is the language, and the second index is the mode-identifier. The third indexes hold properties: terminators, and optionally, submodes, delimiters, and tunnel targets.
A useful set of mode definitions for a nameless general C-type language is shown here. (Don't be confused by the double backslash escaping needed in awk. One set of escaping is for the string, and the second set of escaping is for the regex).
To do: TODO: Add =<\mode{}> command which will allow us to signify that a string is
 regex and thus fangle will quote it for us.

Submodes are entered by the characters  " ' { ( [ /*

47c <common-mode-definitions[1](language), lang=> ≡  48a⊳
      ________________________________________________________________________
  1  | modes[${language}, "",  "submodes"]="\\\\|\"|'|{|\\(|\\[";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
In the default mode, a comma surrounded by un-important white space is a delimiter of language items2. whatever a language item might be  ^2.

48a <common-mode-definitions[2](language) ⇑47c, lang=> +≡ ⊲47c 48c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  2  | modes[${language}, "",  "delimiters"]=" *, *";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
and should pass this test:
To do: Why do the tests run in ?(? mode and not ?? mode


48b <test:mode-definitions[1](), lang=> ≡  49f⊳
      ________________________________________________________________________
  1  | parse_chunk_args("c-like", "1,2,3", a, "");
  2  | if (a[1] != "1") e++;
  3  | if (a[2] != "2") e++;
  4  | if (a[3] != "3") e++;
  5  | if (length(a) != 3) e++;
  6  | «pca-test.awk:summary 57d»
  7  | 
  8  | parse_chunk_args("c-like", "joe, red", a, "");
  9  | if (a[1] != "joe") e++;
  10  | if (a[2] != "red") e++;
  11  | if (length(a) != 2) e++;
  12  | «pca-test.awk:summary 57d»
  13  | 
  14  | parse_chunk_args("c-like", "${colour}", a, "");
  15  | if (a[1] != "${colour}") e++;
  16  | if (length(a) != 1) e++;
  17  | «pca-test.awk:summary 57d»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Nested modes are identified by a backslash, a double or single quote, various bracket styles or a /* comment.
For each of these sub-modes modes we must also identify at a mode terminator, and any sub-modes or delimiters that may be entered3. Because we are using the sub-mode characters as the mode identifier it means we can't currently have a mode character dependant on it's context; i.e. { can't behave differently when it is inside [.  ^3.
10.5.1 Backslash 
The backslash mode has no submodes or delimiters, and is terminated by any character. Note that we are not so much interested in evaluating or interpolating content as we are in delineating content. It is no matter that a double backslash (\\) may represent a single backslash while a backslash-newline may represent white space, but it does matter that the newline in a backslash newline should not be able to terminate a C pre-processor statement; and so the newline will be consumed by the backslash however it is to be interpreted.

48c <common-mode-definitions[3](language) ⇑47c, lang=> +≡ ▵48a 49e⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  3  | modes[${language}, "\\", "terminators"]=".";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
10.5.2 Strings 
Common languages support two kinds of strings quoting, double quotes and single quotes.
In a string we have one special mode, which is the backslash. This may escape an embedded quote and prevent us thinking that it should terminate the string.

48d <mode:common-string[1](language, quote), lang=> ≡  49a⊳
      ________________________________________________________________________
  1  | modes[${language}, ${quote}, "submodes"]="\\\\";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Otherwise, the string will be terminated by the same character that commenced it.

49a <mode:common-string[2](language, quote) ⇑48d, lang=> +≡ ⊲48d 49b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  2  | modes[${language}, ${quote}, "terminators"]=${quote};
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
In C type languages, certain escape sequences exist in strings. We need to define mechanism to enclode any chunks included in this mode using those escape sequences. These are expressed in two parts, s meaning search, and r meaning replace.
The first substitution is to replace a backslash with a double backslash. We do this first as other substitutions may introduce a backslash which we would not then want to escape again here.
Note: Backslashes need double-escaping in the search pattern but not in the replacement string, hence we are replacing a literal \ with a literal \\.

49b <mode:common-string[3](language, quote) ⇑48d, lang=> +≡ ▵49a 49c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  3  | escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]="\\\\";
  4  | escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\\\";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If the quote character occurs in the text, it should be preceded by a backslash, otherwise it would terminate the string unexpectedly.

49c <mode:common-string[4](language, quote) ⇑48d, lang=> +≡ ▵49b 49d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  5  | escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]=${quote};
  6  | escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\" ${quote};
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Any newlines in the string, must be replaced by \n.

49d <mode:common-string[5](language, quote) ⇑48d, lang=> +≡ ▵49c
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  7  | escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]="\n";
  8  | escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\n";
     |________________________________________________________________________


For the common modes, we define this string handling for double and single quotes.

49e <common-mode-definitions[4](language) ⇑47c, lang=> +≡ ⊲48c 50a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  4  | «mode:common-string(${language}, "\"") 48d»
  5  | «mode:common-string(${language}, "'") 48d»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Working strings should pass this test:

49f <test:mode-definitions[2]() ⇑48b, lang=> +≡ ⊲48b 52a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  18  | parse_chunk_args("c-like", "say \"I said, \\\"Hello, how are you\\\".\", for me", a, "");
  19  | if (a[1] != "say \"I said, \\\"Hello, how are you\\\".\"") e++;
  20  | if (a[2] != "for me") e++;
  21  | if (length(a) != 2) e++;
  22  | «pca-test.awk:summary 57d»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
10.5.3 Parentheses, Braces and Brackets 
Where quotes are closed by the same character, parentheses, brackets and braces are closed by an alternate character.

49g <mode:common-brackets[1](language, open, close), lang=> ≡ 
      ________________________________________________________________________
  1  | modes[${language}, ${open},  "submodes" ]="\\\\|\"|{|\\(|\\[|'|/\\*";
  2  | modes[${language}, ${open},  "delimiters"]=" *, *";
  3  | modes[${language}, ${open},  "terminators"]=${close};
     |________________________________________________________________________


Note that the open is NOT a regex but the close token IS. 
To do: When we can quote regex we won't have to put the slashes in here


50a <common-mode-definitions[5](language) ⇑47c, lang=> +≡ ⊲49e
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  6  | «mode:common-brackets(${language}, "{", "}") 49g»
  7  | «mode:common-brackets(${language}, "[", "\\]") 49g»
  8  | «mode:common-brackets(${language}, "(", "\\)") 49g»
     |________________________________________________________________________


10.5.4 Customizing Standard Modes 

50b <mode:add-submode[1](language, mode, submode), lang=> ≡ 
      ________________________________________________________________________
  1  | modes[${language}, ${mode}, "submodes"] = modes[${language}, ${mode}, "submodes"] "|" ${submode};
     |________________________________________________________________________



50c <mode:add-escapes[1](language, mode, search, replace), lang=> ≡ 
      ________________________________________________________________________
  1  | escapes[${language}, ${mode}, ++escapes[${language}, ${mode}], "s"]=${search};
  2  | escapes[${language}, ${mode},   escapes[${language}, ${mode}], "r"]=${replace};
     |________________________________________________________________________



10.5.5 Comments 
We can define /* comment */ style comments and //comment style comments to be added to any language:

50d <mode:multi-line-comments[1](language), lang=> ≡ 
      ________________________________________________________________________
  1  | «mode:add-submode(${language}, "", "/\\*") 50b»
  2  | modes[${language}, "/*", "terminators"]="\\*/";
     |________________________________________________________________________



50e <mode:single-line-slash-comments[1](language), lang=> ≡ 
      ________________________________________________________________________
  1  | «mode:add-submode(${language}, "", "//") 50b»
  2  | modes[${language}, "//", "terminators"]="\n";
  3  | «mode:add-escapes(${language}, "//", "\n", "\n//") 50c»
     |________________________________________________________________________


We can also define # comment style comments (as used in awk and shell scripts) in a similar manner.
To do: I'm having to use # for hash and ¯extbackslash{} for  and have hacky work-arounds in the parser for now


50f <mode:add-hash-comments[1](language), lang=> ≡ 
      ________________________________________________________________________
  1  | «mode:add-submode(${language}, "", "#") 50b»
  2  | modes[${language}, "#", "terminators"]="\n";
  3  | «mode:add-escapes(${language}, "#", "\n", "\n#") 50c»
     |________________________________________________________________________


In C, the # denotes pre-processor directives which can be multi-line

50g <mode:add-hash-defines[1](language), lang=> ≡ 
      ________________________________________________________________________
  1  | «mode:add-submode(${language}, "", "#") 50b»
  2  | modes[${language}, "#", "submodes" ]="\\\\";
  3  | modes[${language}, "#", "terminators"]="\n";
  4  | «mode:add-escapes(${language}, "#", "\n", "\\\\\n") 50c»
     |________________________________________________________________________



51a <mode:quote-dollar-escape[1](language, quote), lang=> ≡ 
      ________________________________________________________________________
  1  | escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]="\\$";
  2  | escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\$";
     |________________________________________________________________________


We can add these definitions to various languages

51b <mode-definitions[1](), lang=> ≡  52a⊳
      ________________________________________________________________________
  1  | «common-mode-definitions("c-like") 47c»
  2  | 
  3  | «common-mode-definitions("c") 47c»
  4  | «mode:multi-line-comments("c") 50d»
  5  | «mode:single-line-slash-comments("c") 50e»
  6  | «mode:add-hash-defines("c") 50g»
  7  | 
  8  | «common-mode-definitions("awk") 47c»
  9  | «mode:add-hash-comments("awk") 50f»
  10  | «mode:add-naked-regex("awk") 51g»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The awk definitions should allow a comment block like this:

51c <test:comment-quote[1](), lang=awk> ≡ 
      ________________________________________________________________________
  1  | # Comment: «test:comment-text 51d»
     |________________________________________________________________________



51d <test:comment-text[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | Now is the time for
  2  | the quick brown fox to bring lemonade
  3  | to the party
     |________________________________________________________________________


to come out like this:

51e <test:comment-quote:result[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | # Comment: Now is the time for
  2  | #the quick brown fox to bring lemonade
  3  | #to the party
     |________________________________________________________________________


The C definition for such a block should have it come out like this:

51f <test:comment-quote:C-result[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | # Comment: Now is the time for\
  2  | the quick brown fox to bring lemonade\
  3  | to the party
     |________________________________________________________________________


10.5.6 Regex 
This pattern is incomplete, but meant to detect naked regular expressions in awk and perl; e.g. /.*$/, however required capabilities are not present.
Current it only detects regexes anchored with ^ as used in fangle.
For full regex support, modes need to be named not after their starting character, but some other more fully qualified name.

51g <mode:add-naked-regex[1](language), lang=> ≡ 
      ________________________________________________________________________
  1  | «mode:add-submode(${language}, "", "/\\^") 50b»
  2  | modes[${language}, "/^", "terminators"]="/";
     |________________________________________________________________________


10.5.7 Perl 

52a <mode-definitions[2]() ⇑51b, lang=> +≡ ⊲51b 52b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  11  | «common-mode-definitions("perl") 47c»
  12  | «mode:multi-line-comments("perl") 50d»
  13  | «mode:add-hash-comments("perl") 50f»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Still need to add add s/, submode /, terminate both with //. This is likely to be impossible as perl regexes can contain perl.
10.5.8 sh 
Shell single-quote strings are different to other strings and have no escape characters. The only special character is the single quote ' which always closes the string. Therefore we cannot use <common-mode-definitions("sh") 47c> but we will invoke most of it's definition apart from single-quote strings. 

52b <mode-definitions[3]() ⇑51b, lang=awk> +≡ ▵52a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  14  | modes["sh", "",  "submodes"]="\\\\|\"|'|{|\\(|\\[|\\$\\(";
  15  | modes["sh", "\\", "terminators"]=".";
  16  | 
  17  | modes["sh", "\"", "submodes"]="\\\\|\\$\\(";
  18  | modes["sh", "\"", "terminators"]="\"";
  19  | escapes["sh", "\"", ++escapes["sh", "\""], "s"]="\\\\";
  20  | escapes["sh", "\"",   escapes["sh", "\""], "r"]="\\\\";
  21  | escapes["sh", "\"", ++escapes["sh", "\""], "s"]="\"";
  22  | escapes["sh", "\"",   escapes["sh", "\""], "r"]="\\" "\"";
  23  | escapes["sh", "\"", ++escapes["sh", "\""], "s"]="\n";
  24  | escapes["sh", "\"",   escapes["sh", "\""], "r"]="\\n";
  25  | 
  26  | modes["sh", "'", "terminators"]="'";
  27  | escapes["sh", "'", ++escapes["sh", "'"], "s"]="'";
  28  | escapes["sh", "'",   escapes["sh", "'"], "r"]="'\\'" "'";
  29  | «mode:common-brackets("sh", "$(", "\\)") 49g»
  30  | «mode:add-tunnel("sh", "$(", "") 52c»
  31  | «mode:common-brackets("sh", "{", "}") 49g»
  32  | «mode:common-brackets("sh", "[", "\\]") 49g»
  33  | «mode:common-brackets("sh", "(", "\\)") 49g»
  34  | «mode:add-hash-comments("sh") 50f»
  35  | «mode:quote-dollar-escape("sh", "\"") 51a»
     |________________________________________________________________________


The definition of add-tunnel is:

52c <mode:add-tunnel[1](language, mode, tunnel), lang=> ≡ 
      ________________________________________________________________________
  1  | escapes[${language}, ${mode}, ++escapes[${language}, ${mode}], "tunnel"]=${tunnel};
     |________________________________________________________________________


10.5.9 Make 
For makefiles, we currently recognize 2 modes: the null mode and ↦ mode, which is tabbed mode. In the null mode the only escape is $ which must be converted to $$. In tabbed mode, the only escape is \n — new lines must also begin with a tab.

?a <mode-definitions[4]() ⇑51b, lang=awk> +≡ ⊲52b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  1  | modes["make", "",  "submodes"]="↦";
  2  | escapes["make", "", ++escapes["make", ""], "s"]="\\$";
  3  | escapes["make", "", ++escapes["make", ""], "r"]="$$";
  4  | modes["make", "↦", "terminators"]="\\n";
  5  | escapes["make", "↦", ++escapes["make", "↦"], "s"]="\\n";
  6  | escapes["make", "↦", ++escapes["make", "↦"], "r"]="\n↦";
     |________________________________________________________________________


10.6 Some tests 
Also, the parser must return any spare text at the end that has not been processed due to a mode terminator being found.

52a <test:mode-definitions[3]() ⇑48b, lang=> +≡ ⊲49f 53a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  23  | rest = parse_chunk_args("c-like", "1, 2, 3) spare", a, "(");
  24  | if (a[1] != 1) e++;
  25  | if (a[2] != 2) e++;
  26  | if (a[3] != 3) e++;
  27  | if (length(a) != 3) e++;
  28  | if (rest != " spare") e++;
  29  | «pca-test.awk:summary 57d»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We must also be able to parse the example given earlier.

53a <test:mode-definitions[4]() ⇑48b, lang=> +≡ ⊲52a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  30  | parse_chunk_args("c-like", "things[x, y], get_other_things(a, \"(all)\"), 99", a, "(");
  31  | if (a[1] != "things[x, y]") e++;
  32  | if (a[2] != "get_other_things(a, \"(all)\")") e++;
  33  | if (a[3] != "99") e++;
  34  | if (length(a) != 3) e++;
  35  | «pca-test.awk:summary 57d»
     |________________________________________________________________________


10.7 A non-recursive mode tracker 
10.7.1 Constructor 
The mode tracker holds its state in a stack based on a numerically indexed hash. This function, when passed an empty hash, will intialize it.

53b <new_mode_tracker()[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function new_mode_tracker(context, language, mode) {
  2  |   context[""] = 0;
  3  |   context[0, "language"] = language;
  4  |   context[0, "mode"] = mode;
  5  | }
     |________________________________________________________________________


Because awk functions cannot return an array, we must create the array first and pass it in, so we have a fangle macro to do this:

53c <new-mode-tracker[1](context, language, mode), lang=awk> ≡ 
      ________________________________________________________________________
  1  | «awk-delete-array(context) 35d»
  2  | new_mode_tracker(${context}, ${language}, ${mode});
     |________________________________________________________________________


10.7.2 Management 
And for tracking modes, we dispatch to a mode-tracker action based on the current language

53d <mode_tracker[1](), lang=awk> ≡  54a⊳
      ________________________________________________________________________
  1  | function push_mode_tracker(context, language, mode,
  2  |   # local vars
  3  |   top)
  4  | {
  5  |   if (! ("" in context)) {
  6  |     «new-mode-tracker(context, language, mode) 53c»
  7  |     return context[""];
  8  |   } else {
  9  |     top = context[""];
  10  |     if (context[top, "language"] == language && mode=="") mode = context[top, "mode"];
  11  |     old_top = top;
  12  |     top++;
  13  |     context[top, "language"] = language;
  14  |     context[top, "mode"] = mode;
  15  |     context[""] = top;
  16  |   }
  17  |   return top;
  18  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

54a <mode_tracker[2]() ⇑53d, lang=> +≡ ⊲53d 54b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  19  | function dump_mode_tracker(context,  
  20  |   c, d)
  21  | {
  22  |   for(c=0; c <= context[""]; c++) {
  23  |     printf(" %2d   %s:%s\n", c, context[c, "language"], context[c, "mode"]) > "/dev/stderr";
  24  |     for(d=1; ( (c, "values", d) in context); d++) {
  25  |       printf("   %2d %s\n", d, context[c, "values", d]) > "/dev/stderr";
  26  |     }
  27  |   }
  28  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

54b <mode_tracker[3]() ⇑53d, lang=> +≡ ▵54a 58b⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  29  | function pop_mode_tracker(context, context_origin)
  30  | {
  31  |   if ( (context_origin) && ("" in context) && context[""] != context_origin) return 0;
  32  |   context[""]--;
  33  |   return 1;
  34  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
This implies that any chunk must be syntactically whole; for instance, this is fine:

54c <test:whole-chunk[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (1) {
  2  |   «test:say-hello 54d»
  3  | }
     |________________________________________________________________________



54d <test:say-hello[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | print "hello";
     |________________________________________________________________________


But this is not fine; the chunk <test:hidden-else 54f> is not properly cromulent.

54e <test:partial-chunk[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (1) {
  2  |   «test:hidden-else 54f»
  3  | }
     |________________________________________________________________________



54f <test:hidden-else[1](), lang=> ≡ 
      ________________________________________________________________________
  1  |   print "I'm fine";
  2  | } else {
  3  |   print "I'm not";
     |________________________________________________________________________


These tests will check for correct behaviour:

54g <test:cromulence[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | echo Cromulence test
  2  | passtest $FANGLE -Rtest:whole-chunk $TXT_SRC &>/dev/null || ( echo "Whole chunk failed" && exit 1 )
  3  | failtest $FANGLE -Rtest:partial-chunk $TXT_SRC &>/dev/null || ( echo "Partial chunk failed" && exit 1 )
     |________________________________________________________________________


10.7.3 Tracker 
We must avoid recursion as a language construct because we intend to employ mode-tracking to track language mode of emitted code, and the code is emitted from a function which is itself recursive, so instead we implement psuedo-recursion using our own stack based on a hash.

55a <mode_tracker()[1](), lang=awk> ≡  55b▿
      ________________________________________________________________________
  1  | function mode_tracker(context, text, values, 
  2  |   # optional parameters
  3  |   # local vars
  4  |   mode, submodes, language,
  5  |   cindex, c, a, part, item, name, result, new_values, new_mode, 
  6  |   delimiters, terminators)
  7  | {
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We could be re-commencing with a valid context, so we need to setup the state according to the last context.

55b <mode_tracker()[2]() ⇑55a, lang=> +≡ ▵55a 55e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  8  |   cindex = context[""] + 0;
  9  |   mode = context[cindex, "mode"];
  10  |   language = context[cindex, "language" ];
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
First we construct a single large regex combining the possible sub-modes for the current mode along with the terminators for the current mode.

55c <parse_chunk_args-reset-modes[1](), lang=> ≡  55d▿
      ________________________________________________________________________
  1  |   submodes=modes[language, mode, "submodes"];
  2  | 
  3  |   if ((language, mode, "delimiters") in modes) {
  4  |     delimiters = modes[language, mode, "delimiters"];
  5  |     if (length(submodes)>0) submodes = submodes "|";
  6  |     submodes=submodes delimiters;
  7  |   } else delimiters="";
  8  |   if ((language, mode, "terminators") in modes) {
  9  |     terminators = modes[language, mode, "terminators"];
  10  |     if (length(submodes)>0) submodes = submodes "|";
  11  |     submodes=submodes terminators;
  12  |   } else terminators="";
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If we don't find anything to match on --- probably because the language is not supported --- then we return the entire text without matching anything.

55d <parse_chunk_args-reset-modes[2]() ⇑55c, lang=> +≡ ▵55c
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  13  |  if (! length(submodes)) return text;
     |________________________________________________________________________



55e <mode_tracker()[3]() ⇑55a, lang=> +≡ ▵55b 55f▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  11  | «parse_chunk_args-reset-modes 55c»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then iterate the text (until there is none left) looking for sub-modes or terminators in the regex.

55f <mode_tracker()[4]() ⇑55a, lang=> +≡ ▵55e 56a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  12  |   while((cindex >= 0) && length(text)) {
  13  |     if (match(text, "(" submodes ")", a)) {
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
A bug that creeps in regularly during development is bad regexes of zero length which result in an infinite loop (as no text is consumed), so I catch that right away with this test.

56a <mode_tracker()[5]() ⇑55a, lang=> +≡ ⊲55f 56b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  14  |       if (RLENGTH<1) {
  15  |         error(sprintf("Internal error, matched zero length submode, should be impossible - likely regex computation error\n" \
  16  |                 "Language=%s\nmode=%s\nmatch=%s\n", language, mode, submodes));
  17  |       }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
part is defined as the text up to the sub-mode or terminator, and this is appended to item --- which is the current text being gathered. If a mode has a delimiter, then item is reset each time a delimiter is found.
("hello_item, there_item")<wide-overbrace>^item,  (he said.)<wide-overbrace>^item

56b <mode_tracker()[6]() ⇑55a, lang=> +≡ ▵56a 56c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  18  |       part = substr(text, 1, RSTART -1);
  19  |       item = item part;
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We must now determine what was matched. If it was a terminator, then we must restore the previous mode.

56c <mode_tracker()[7]() ⇑55a, lang=> +≡ ▵56b 56d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  20  |       if (match(a[1], "^" terminators "$")) {
  21  | #printf("%2d EXIT  MODE [%s] by [%s] [%s]\n", cindex, mode, a[1], text) > "/dev/stderr"
  22  |         context[cindex, "values", ++context[cindex, "values"]] = item;
  23  |         delete context[cindex];
  24  |         context[""] = --cindex;
  25  |         if (cindex>=0) {
  26  |           mode = context[cindex, "mode"];
  27  |           language = context[cindex, "language"];
  28  |           «parse_chunk_args-reset-modes 55c»
  29  |         }
  30  |         item = item a[1];
  31  |         text = substr(text, 1 + length(part) + length(a[1]));
  32  |       }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If a delimiter was matched, then we must store the current item in the parsed values array, and reset the item.

56d <mode_tracker()[8]() ⇑55a, lang=> +≡ ▵56c 56e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  33  |       else if (match(a[1], "^" delimiters "$")) {
  34  |         if (cindex==0) {
  35  |           context[cindex, "values", ++context[cindex, "values"]] = item;
  36  |           item = "";
  37  |         } else {
  38  |           item = item a[1];
  39  |         }
  40  |         text = substr(text, 1 + length(part) + length(a[1]));
  41  |       }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
otherwise, if a new submode is detected (all submodes have terminators), we must create a nested parse context until we find the terminator for this mode.

56e <mode_tracker()[9]() ⇑55a, lang=> +≡ ▵56d 57a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  42  |  else if ((language, a[1], "terminators") in modes) {
  43  |         #check if new_mode is defined
  44  |         item = item a[1];
  45  | #printf("%2d ENTER MODE [%s] in [%s]\n", cindex, a[1], text) > "/dev/stderr"
  46  |         text = substr(text, 1 + length(part) + length(a[1]));
  47  |         context[""] = ++cindex;
  48  |         context[cindex, "mode"] = a[1];
  49  |         context[cindex, "language"] = language;
  50  |         mode = a[1];
  51  |         «parse_chunk_args-reset-modes 55c»
  52  |       } else {
  53  |         error(sprintf("Submode '%s' set unknown mode in text: %s\nLanguage %s Mode %s\n", a[1], text, language, mode));
  54  |         text = substr(text, 1 + length(part) + length(a[1]));
  55  |       }
  56  |     }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
In the final case, we parsed to the end of the string. If the string was entire, then we should have no nested mode context, but if the string was just a fragment we may have a mode context which must be preserved for the next fragment. Todo: Consideration ought to be given if sub-mode strings are split over two fragments.

57a <mode_tracker()[10]() ⇑55a, lang=> +≡ ⊲56e
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  57  | else {
  58  |       context[cindex, "values", ++context[cindex, "values"]] = item text;
  59  |       text = "";
  60  |       item = "";
  61  |     }
  62  |   }
  63  | 
  64  |   context["item"] = item;
  65  | 
  66  |   if (length(item)) context[cindex, "values", ++context[cindex, "values"]] = item;
  67  |   return text;
  68  | }
     |________________________________________________________________________


10.7.3.1 One happy chunk 
All the mode tracker chunks are referred to here:

57b <mode-tracker[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | «new_mode_tracker() 53b»
  2  | «mode_tracker() 55a»
     |________________________________________________________________________


10.7.3.2 Tests 
We can test this function like this:

57c <pca-test.awk[1](), lang=awk> ≡ 
      ________________________________________________________________________
  1  | «error() 36a»
  2  | «mode-tracker 57b»
  3  | «parse_chunk_args() ?»
  4  | BEGIN {
  5  |   SUBSEP=".";
  6  |   «mode-definitions 51b»
  7  | 
  8  |   «test:mode-definitions 48b»
  9  | }
     |________________________________________________________________________



57d <pca-test.awk:summary[1](), lang=awk> ≡ 
      ________________________________________________________________________
  1  | if (e) {
  2  |   printf "Failed " e
  3  |   for (b in a) {
  4  |     print "a[" b "] => " a[b];
  5  |   }
  6  | } else {
  7  |   print "Passed"
  8  | }
  9  | split("", a);
  10  | e=0;
     |________________________________________________________________________


which should give this output:

58a <pca-test.awk-results[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | a[foo.quux.quirk] => 
  2  | a[foo.quux.a] => fleeg
  3  | a[foo.bar] => baz
  4  | a[etc] => 
  5  | a[name] => freddie
     |________________________________________________________________________


10.8 Escaping and Quoting 
For the time being and to get around TeXmacs inability to export a TAB character, the right arrow ↦ whose UTF-8 sequence is ...
To do: complete

Another special character is used, the left-arrow ↤ with UTF-8 sequence 0xE2 0x86 0xA4 is used to strip any preceding white space as a way of un-tabbing and removing indent that has been applied — this is important for bash here documents, and the like. It's a filthy hack.
To do: remove the hack


58b <mode_tracker[4]() ⇑53d, lang=> +≡ ⊲54b 58c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

  35  | function untab(text) {
  36  |   gsub("[[:space:]]*\xE2\x86\xA4","", text);
  37  |   return text;
  38  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Each nested mode can optionally define a set of transforms to be applied to any text that is included from another language.
This code can perform transforms from index c downwards.

58c <mode_tracker[5]() ⇑53d, lang=awk> +≡ ▵58b 58c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  39  | function transform_escape(context, text, top,
  40  |   c, cp, cpl, s, r)
  41  | {
  42  |   for(c = top; c >= 0; c--) {
  43  |     if ( (context[c, "language"], context[c, "mode"]) in escapes) {
  44  |       cpl = escapes[context[c, "language"], context[c, "mode"]];
  45  |       for (cp = 1; cp <= cpl; cp ++) {
  46  |         s = escapes[context[c, "language"], context[c, "mode"], cp, "s"];
  47  |         r = escapes[context[c, "language"], context[c, "mode"], cp, "r"];
  48  |         if (length(s)) {
  49  |           gsub(s, r, text);
  50  |         }
  51  |         if ( (context[c, "language"], context[c, "mode"], cp, "t") in escapes ) {
  52  |           quotes[src, "t"] = escapes[context[c, "language"], context[c, "mode"], cp, "t"];
  53  |         }
  54  |       }
  55  |     }
  56  |   }
  57  |   return text;
  58  | }
  59  | function dump_escaper(quotes, r, cc) {
  60  |   for(cc=1; cc<=c; cc++) {
  61  |     printf("%2d s[%s] r[%s]\n", cc, quotes[cc, "s"], quotes[cc, "r"]) > "/dev/stderr"
  62  |   }
  63  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

59a <test:escapes[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | echo escapes test
  2  | passtest $FANGLE -Rtest:comment-quote $TXT_SRC &>/dev/null || ( echo "Comment-quote failed" && exit 1 )
     |________________________________________________________________________


Chapter 11Recognizing Chunks
Fangle recognizes noweb chunks, but as we also want better LaTeX integration we will recognize any of these:
•  notangle chunks matching the pattern ^<<.*?>>=
•  chunks beginning with \begin{lstlistings}, possibly with \Chunk{...} on the previous line
•  an older form I have used, beginning with \begin{Chunk}[options] --- also more suitable for plain LaTeX users1. Is there such a thing as plain LaTeX?  ^1. 
11.1 Chunk start 
The variable chunking is used to signify that we are processing a code chunk and not document. In such a state, input lines will be assigned to the current chunk; otherwise they are ignored.
11.1.1 TeXmacs 
We don't handle TeXmacs files natively yet, but rather instead emit unicode character sequences to mark up the text-export file which we do process.
These hacks detect the unicode character sequences and retro-fit in the old TeX parsing.
We convert ↦ into a tab character.

61a <recognize-chunk[1](), lang=> ≡  61b▿
      ________________________________________________________________________

  1  | #/\n/ {
  2  | #  gsub("\n*$","");
  3  | #  gsub("\n", " ");
  4  | #}
  5  | #===
  6  | /\xE2\x86\xA6/ {
  7  |   gsub("\\xE2\\x86\\xA6", "\x09");
  8  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
TeXmacs back-tick handling is obscure, and a cut-n-paste back-tick from a shell window comes out as a unicode sequence2. that won't export to html, except as a NULL character (literal 0x00)  ^2 that is fixed-up here.

61b <recognize-chunk[2]() ⇑61a, lang=> +≡ ▵61a 62a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  9  | 
  10  | /\xE2\x80\x98/ {
  11  |   gsub("\\xE2\\x80\\x98", "‘");
  12  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
In the TeXmacs output, the start of a chunk will appear like this:
  5b<example-chunk^K[1](arg1,^K arg2^K^K), lang=C> ≡
We detect the the start of a TeXmacs chunk by detecting the ≡ symbol which occurs near the end of the line. We obtain the chunk name, the chunk parameters, and the chunk language.

62a <recognize-chunk[3]() ⇑61a, lang=> +≡ ⊲61b 62b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  13  | 
  14  | /\xE2\x89\xA1/ {
  15  |   if (match($0, "^ *([^[ ]* |)<([^[ ]*)\\[[0-9]*\\][(](.*)[)].*, lang=([^ ]*)>", line)) {
  16  |     next_chunk_name=line[2];
  17  |     get_texmacs_chunk_args(line[3], next_chunk_params);
  18  |     gsub(ARG_SEPARATOR ",? ?", ";", line[3]);
  19  |     params = "params=" line[3];
  20  |     if ((line[4])) {
  21  |       params = params ",language=" line[4]
  22  |     }
  23  |     get_tex_chunk_args(params, next_chunk_opts);
  24  |     new_chunk(next_chunk_name, next_chunk_opts, next_chunk_params);
  25  |     texmacs_chunking = 1;
  26  |   } else {
  27  |     # warning(sprintf("Unexpected chunk match: %s\n", $_))
  28  |   }
  29  |   next;
  30  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.1.2 lstlistings 
Our current scheme is to recognize the new lstlisting chunks, but these may be preceded by a \Chunk command which in L Y X is a more convenient way to pass the chunk name to the \begin{lstlistings} command, and a more visible way to specify other lstset settings.
The arguments to the \Chunk command are a name, and then a comma-seperated list of key-value pairs after the manner of \lstset. (In fact within the LaTeX \Chunk macro (section 16.2.1) the text name= is prefixed to the argument which is then literally passed to \lstset).

62b <recognize-chunk[4]() ⇑61a, lang=awk> +≡ ▵62a 62c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  31  | /^\\Chunk{/ {
  32  |   if (match($0, "^\\\\Chunk{ *([^ ,}]*),?(.*)}", line)) {
  33  |     next_chunk_name = line[1];
  34  |     get_tex_chunk_args(line[2], next_chunk_opts);
  35  |   }
  36  |   next;
  37  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also make a basic attempt to parse the name out of the \lstlistings[name=chunk-name] text, otherwise we fall back to the name found in the previous chunk command. This attempt is very basic and doesn't support commas or spaces or square brackets as part of the chunkname. We also recognize \begin{Chunk} which is convenient for some users3. but not yet supported in the LaTeX macros  ^3.

62c <recognize-chunk[5]() ⇑61a, lang=> +≡ ▵62b 63a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  38  | /^\\begin{lstlisting}|^\\begin{Chunk}/ {
  39  |   if (match($0, "}.*[[,] *name= *{? *([^], }]*)", line)) {
  40  |     new_chunk(line[1]);
  41  |   } else {
  42  |     new_chunk(next_chunk_name, next_chunk_opts);
  43  |   }
  44  |   chunking=1;
  45  |   next;
  46  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.2 Chunk Body 
11.2.1 TeXmacs 
A chunk body in TeXmacs ends with |________... if it is the final chunklet of a chunk, or if there are further chunklets it ends with |\/\/\/... which is a depiction of a jagged line of torn paper.

63a <recognize-chunk[6]() ⇑61a, lang=> +≡ ⊲62c 63b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  47  | /^ *\|____________*/ && texmacs_chunking {
  48  |   active_chunk="";
  49  |   texmacs_chunking=0;
  50  |   chunking=0;
  51  | }
  52  | /^ *\|\/\\/ && texmacs_chunking {
  53  |   texmacs_chunking=0;
  54  |   chunking=0;
  55  |   active_chunk="";
  56  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
It has been observed that not every line of output when a TeXmacs chunk is active is a line of chunk. This may no longer be true, but we set a variable texmacs_chunk if the current line is a chunk line.
Initially we set this to zero...

63b <recognize-chunk[7]() ⇑61a, lang=> +≡ ▵63a 63c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  57  | texmacs_chunk=0;
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
...and then we look to see if the current line is a chunk line.
TeXmacs lines look like this:   3 | main() { so we detect the lines by leading white space, digits, more whiter space and a vertical bar followed by at least once space.
If we find such a line, we remove this line-header and set texmacs_chunk=1 as well as chunking=1

63c <recognize-chunk[8]() ⇑61a, lang=> +≡ ▵63b 63d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  58  | /^ *[1-9][0-9]* *\| / {
  59  |   if (texmacs_chunking) {
  60  |     chunking=1;
  61  |     texmacs_chunk=1;
  62  |     gsub("^ *[1-9][0-9]* *\\| ", "")
  63  |   }
  64  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
When TeXmacs chunking, lines that commence with \/ or __ are not chunk content but visual framing, and are skipped.

63d <recognize-chunk[9]() ⇑61a, lang=> +≡ ▵63c 64a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  65  | /^ *\.\/\\/ && texmacs_chunking {
  66  |   next;
  67  | }
  68  | /^ *__*$/ && texmacs_chunking {
  69  |   next;
  70  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Any other line when TeXmacs chunking is considered to be a line-wrapped line.

64a <recognize-chunk[10]() ⇑61a, lang=> +≡ ⊲63d 64b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  71  | texmacs_chunking {
  72  |   if (! texmacs_chunk) {
  73  |     # must be a texmacs continued line
  74  |     chunking=1;
  75  |     texmacs_chunk=1;
  76  |   }
  77  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
This final chunklet seems bogus and probably stops L Y X working.

64b <recognize-chunk[11]() ⇑61a, lang=> +≡ ▵64a 64c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  78  | ! texmacs_chunk {
  79  | #  texmacs_chunking=0;
  80  |   chunking=0;
  81  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.2.2 Noweb 
We recognize notangle style chunks too:

64c <recognize-chunk[12]() ⇑61a, lang=awk> +≡ ▵64b 64d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  82  | /^[<]<.*[>]>=/ {
  83  |   if (match($0, "^[<]<(.*)[>]>= *$", line)) {
  84  |     chunking=1;
  85  |     notangle_mode=1;
  86  |     new_chunk(line[1]);
  87  |     next;
  88  |   }
  89  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.3 Chunk end 
Likewise, we need to recognize when a chunk ends.
11.3.1 lstlistings 
The e in [e]nd{lislisting} is surrounded by square brackets so that when this document is processed, this chunk doesn't terminate early when the lstlistings package recognizes it's own end-string!4. This doesn't make sense as the regex is anchored with ^, which this line does not begin with!  ^4

64d <recognize-chunk[13]() ⇑61a, lang=> +≡ ▵64c 65a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  90  | /^\\[e]nd{lstlisting}|^\\[e]nd{Chunk}/ {
  91  |   chunking=0;
  92  |   active_chunk="";
  93  |   next;
  94  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.3.2 noweb 

65a <recognize-chunk[14]() ⇑61a, lang=> +≡ ⊲64d 65b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  95  | /^@ *$/ {
  96  |   chunking=0;
  97  |   active_chunk="";
  98  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
All other recognizers are only of effect if we are chunking; there's no point in looking at lines if they aren't part of a chunk, so we just ignore them as efficiently as we can.

65b <recognize-chunk[15]() ⇑61a, lang=> +≡ ▵65a 65c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  99  | ! chunking { next; }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
11.4 Chunk contents 
Chunk contents are any lines read while chunking is true. Some chunk contents are special in that they refer to other chunks, and will be replaced by the contents of these chunks when the file is generated.
We add the output record separator ORS to the line now, because we will set ORS to the empty string when we generate the output5. So that we can partial print lines using print instead of printf. 
To do: This does't make sense
^5.

65c <recognize-chunk[16]() ⇑61a, lang=> +≡ ▵65b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  100  | length(active_chunk) {
  101  |   «process-chunk-tabs 65e»
  102  |   «process-chunk 66b»
  103  | }
     |________________________________________________________________________


If a chunk just consisted of plain text, we could handle the chunk like this:

65d <process-chunk-simple[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | chunk_line(active_chunk, $0 ORS);
     |________________________________________________________________________


but in fact a chunk can include references to other chunks. Chunk includes are traditionally written as <<chunk-name>> but we support other variations, some of which are more suitable for particular editing systems.
However, we also process tabs at this point. A tab at input can be replaced by a number of spaces defined by the tabs variable, set by the -T option. Of course this is poor tab behaviour, we should probably have the option to use proper counted tab-stops and process this on output.

65e <process-chunk-tabs[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (length(tabs)) {
  2  |   gsub("\t", tabs);
  3  | }
     |________________________________________________________________________


11.4.1 lstlistings 
If \lstset{escapeinside={=<}{>}} is set, then we can use <chunk-name ?> in listings. The sequence =< was chosen because:
1.it is a better mnemonic than <<chunk-name>> in that the = sign signifies equivalence or substitutability.
2.and because =< is not valid in C or any language I can think of.
3.and also because lstlistings doesn't like >> as an end delimiter for the texcl escape, so we must make do with a single > which is better complemented by =< than by <<. 
Unfortunately the =<...> that we use re-enters a LaTeX parsing mode in which some characters are special, e.g. # \ and so these cause trouble if used in arguments to \chunkref. At some point I must fix the LaTeX command \chunkref so that it can accept these literally, but until then, when writing chunkref argumemts that need these characters, I must use the forms \textbackslash{} and \#; so I also define a hacky chunk delatex to be used further on whose purpose it is to remove these from any arguments parsed by fangle.

66a <delatex[1](text), lang=> ≡ 
      ________________________________________________________________________
  1  | # FILTHY HACK
  2  | gsub("\\\\#", "#", ${text});
  3  | gsub("\\\\textbackslash{}", "\\", ${text});
  4  | gsub("\\\\\\^", "^", ${text});
     |________________________________________________________________________


As each chunk line may contain more than one chunk include, we will split out chunk includes in an iterative fashion6. Contrary to our use of split when substituting parameters in chapter ?  ^6.
First, as long as the chunk contains a \chunkref command we take as much as we can up to the first \chunkref command.
TeXmacs text output uses ⟨...⟩ which comes out as unicode sequences 0xC2 0xAB ... 0xC2 0xBB. Modern awk will interpret [^\xC2\xBB] as a single unicode character if LANG is set correctly to the sub-type UTF-8, e.g. LANG=en_GB.UTF-8, otherwise [^\xC2\xBB] will be treated as a two character negated match — but this should not interfere with the function.

66b <process-chunk[1](), lang=> ≡  66c▿
      ________________________________________________________________________
  1  | chunk = $0;
  2  | indent = 0;
  3  | while(match(chunk,"(\xC2\xAB)([^\xC2\xBB]*) [^\xC2\xBB]*\xC2\xBB", line) ||
  4  |       match(chunk, 
  5  |             "([=]<\\\\chunkref{([^}>]*)}(\\(.*\\)|)>|<<([a-zA-Z_][-a-zA-Z0-9_]*)>>)", 
  6  |             line)\
  7  | ) {
  8  |   chunklet = substr(chunk, 1, RSTART - 1);
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We keep track of the indent count, by counting the number of literal characters found. We can then preserve this indent on each output line when multi-line chunks are expanded.
We then process this first part literal text, and set the chunk which is still to be processed to be the text after the \chunkref command, which we will process next as we continue around the loop.

66c <process-chunk[2]() ⇑66b, lang=> +≡ ▵66b 67a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  9  |   indent += length(chunklet);
  10  |   chunk_line(active_chunk, chunklet);
  11  |   chunk = substr(chunk, RSTART + RLENGTH);
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then consider the type of chunk command we have found, whether it is the fangle style command beginning with =< the older notangle style beginning with <<.
Fangle chunks may have parameters contained within square brackets. These will be matched in line[3] and are considered at this stage of processing to be part of the name of the chunk to be included.

67a <process-chunk[3]() ⇑66b, lang=> +≡ ⊲66c 67b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  12  |   if (substr(line[1], 1, 1) == "=") {
  13  |     # chunk name up to }
  14  |         «delatex(line[3]) 66a»
  15  |     chunk_include(active_chunk, line[2] line[3], indent);
  16  |   } else if (substr(line[1], 1, 1) == "<") {
  17  |     chunk_include(active_chunk, line[4], indent);
  18  |   } else if (line[1] == "\xC2\xAB") {
  19  |     chunk_include(active_chunk, line[2], indent);
  20  |   } else {
  21  |     error("Unknown chunk fragment: " line[1]);
  22  |   }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The loop will continue until there are no more chunkref statements in the text, at which point we process the final part of the chunk.

67b <process-chunk[4]() ⇑66b, lang=> +≡ ▵67a 67c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  23  | }
  24  | chunk_line(active_chunk, chunk);
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We add the newline character as a chunklet on it's own, to make it easier to detect new lines and thus manage indentation when processing the output.

67c <process-chunk[5]() ⇑66b, lang=> +≡ ▵67b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  25  | chunk_line(active_chunk, "\n");
     |________________________________________________________________________


We will also permit a chunk-part number to follow in square brackets, so that <chunk-name[1] ?> will refer to the first part only. This can make it easy to include a C function prototype in a header file, if the first part of the chunk is just the function prototype without the trailing semi-colon. The header file would include the prototype with the trailing semi-colon, like this:
<chunk-name[1] ?>
This is handled in section 13.1.1
We should perhaps introduce a notion of language specific chunk options; so that perhaps we could specify:
=<\chunkref{chunk-name[function-declaration]}
which applies a transform function-declaration to the chunk --- which in this case would extract a function prototype from a function. 
To do: Do it

Chapter 12Processing Options
At the start, first we set the default options.

69a <default-options[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | debug=0;
  2  | linenos=0;
  3  | notangle_mode=0;
  4  | root="*";
  5  | tabs = "";
     |________________________________________________________________________


Then we use getopt the standard way, and null out ARGV afterwards in the normal AWK fashion.

69b <read-options[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | Optind = 1    # skip ARGV[0]
  2  | while(getopt(ARGC, ARGV, "R:LdT:hr")!=-1) {
  3  |   «handle-options 69c»
  4  | }
  5  | for (i=1; i<Optind; i++) { ARGV[i]=""; }
     |________________________________________________________________________


This is how we handle our options:

69c <handle-options[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (Optopt == "R") root = Optarg;
  2  | else if (Optopt == "r") root="";
  3  | else if (Optopt == "L") linenos = 1;
  4  | else if (Optopt == "d") debug = 1;
  5  | else if (Optopt == "T") tabs = indent_string(Optarg+0);
  6  | else if (Optopt == "h") help();
  7  | else if (Optopt == "?") help();
     |________________________________________________________________________


We do all of this at the beginning of the program

69d <begin[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | BEGIN {
  2  |   «constants 37a»
  3  |   «mode-definitions 51b»
  4  |   «default-options 69a»
  5  | 
  6  |   «read-options 69b»
  7  | }
     |________________________________________________________________________


And have a simple help function

69e <help()[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function help() {
  2  |   print "Usage:"
  3  |   print "  fangle [-L] -R<rootname> [source.tex ...]"
  4  |   print "  fangle -r [source.tex ...]"
  5  |   print "  If the filename, source.tex is not specified then stdin is used"
  6  |   print
  7  |   print "-L causes the C statement: #line <lineno> \"filename\"" to be issued"
  8  |   print "-R causes the named root to be written to stdout"
  9  |   print "-r lists all roots in the file (even those used elsewhere)"
  10  |   exit 1;
  11  | }
     |________________________________________________________________________


Chapter 13Generating the Output
We generate output by calling output_chunk, or listing the chunk names.

71a <generate-output[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (length(root)) output_chunk(root);
  2  | else output_chunk_names();
     |________________________________________________________________________


We also have some other output debugging:

71b <debug-output[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (debug) {
  2  |   print "------ chunk names "
  3  |   output_chunk_names();
  4  |   print "====== chunks"
  5  |   output_chunks();
  6  |   print "++++++ debug"
  7  |   for (a in chunks) {
  8  |     print a "=" chunks[a];
  9  |   }
  10  | }
     |________________________________________________________________________


We do both of these at the end. We also set ORS="" because each chunklet is not necessarily a complete line, and we already added ORS to each input line in section 11.4.

71c <end[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | END {
  2  |   «debug-output 71b»
  3  |   ORS="";
  4  |   «generate-output 71a»
  5  | }
     |________________________________________________________________________


We write chunk names like this. If we seem to be running in notangle compatibility mode, then we enclose the name like this <<name>> the same way notangle does:

71d <output_chunk_names()[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function output_chunk_names(   c, prefix, suffix) 
  2  | {
  3  |   if (notangle_mode) {
  4  |     prefix="<<";
  5  |     suffix=">>";
  6  |   }
  7  |   for (c in chunk_names) {
  8  |     print prefix c suffix "\n";
  9  |   }
  10  | }
     |________________________________________________________________________


This function would write out all chunks

71e <output_chunks()[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | function output_chunks(  a) 
  2  | {
  3  |   for (a in chunk_names) {
  4  |     output_chunk(a);
  5  |   }
  6  | }
  7  | 
  8  | function output_chunk(chunk) {
  9  |   newline = 1;
  10  |   lineno_needed = linenos;
  11  | 
  12  |   write_chunk(chunk);
  13  | }
  14  | 
     |________________________________________________________________________


13.1 Assembling the Chunks 
chunk_path holds a string consisting of the names of all the chunks that resulted in this chunk being output. It should probably also contain the source line numbers at which each inclusion also occured.
We first initialize the mode tracker for this chunk.

72a <write_chunk()[1](), lang=awk> ≡  72b▿
      ________________________________________________________________________
  1  | function write_chunk(chunk_name) {
  2  |   «awk-delete-array(context) 35d»
  3  |   return write_chunk_r(chunk_name, context);
  4  | }
  5  | 
  6  | function write_chunk_r(chunk_name, context, indent, tail,
  7  |   # optional vars
  8  |   chunk_path, chunk_args, 
  9  |   # local vars
  10  |   context_origin,
  11  |   chunk_params, part, max_part, part_line, frag, max_frag, text, 
  12  |   chunklet, only_part, call_chunk_args, new_context)
  13  | {
  14  |   if (debug) debug_log("write_chunk_r(" chunk_name ")");
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
13.1.1 Chunk Parts 
As mentioned in section ?, a chunk name may contain a part specifier in square brackets, limiting the parts that should be emitted.

72b <write_chunk()[2]() ⇑72a, lang=> +≡ ▵72a 72c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  15  |   if (match(chunk_name, "^(.*)\\[([0-9]*)\\]$", chunk_name_parts)) {
  16  |     chunk_name = chunk_name_parts[1];
  17  |     only_part = chunk_name_parts[2];
  18  |   }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then create a mode tracker

72c <write_chunk()[3]() ⇑72a, lang=> +≡ ▵72b 73a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  19  |   context_origin = push_mode_tracker(context, chunks[chunk_name, "language"], "");
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We extract into chunk_params the names of the parameters that this chunk accepts, whose values were (optionally) passed in chunk_args.

73a <write_chunk()[4]() ⇑72a, lang=> +≡ ⊲72c 73b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  20  |   split(chunks[chunk_name, "params"], chunk_params, " *; *");
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
To assemble a chunk, we write out each part.

73b <write_chunk()[5]() ⇑72a, lang=> +≡ ▵73a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  21  |   if (! (chunk_name in chunk_names)) {
  22  |     error(sprintf(_"The root module <<%s>> was not defined.\nUsed by: %s",\
  23  |                   chunk_name, chunk_path));
  24  |   }
  25  | 
  26  |   max_part = chunks[chunk_name, "part"];
  27  |   for(part = 1; part <= max_part; part++) {
  28  |     if (! only_part || part == only_part) {
  29  |       «write-part 73c»
  30  |     }
  31  |   }
  32  |   if (! pop_mode_tracker(context, context_origin)) {
  33  |     dump_mode_tracker(context);
  34  |     error(sprintf(_"Module %s did not close context properly.\nUsed by: %s\n", chunk_name, chunk_path));
  35  |   }
  36  | }
     |________________________________________________________________________


A part can either be a chunklet of lines, or an include of another chunk.
Chunks may also have parameters, specified in LaTeX style with braces after the chunk name --- looking like this in the document: chunkname{param1, param2}. Arguments are passed in square brackets: \chunkref{chunkname}[arg1, arg2].
Before we process each part, we check that the source position hasn't changed unexpectedly, so that we can know if we need to output a new file-line directive.

73c <write-part[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | «check-source-jump 75d»
  2  | 
  3  | chunklet = chunks[chunk_name, "part", part];
  4  | if (chunks[chunk_name, "part", part, "type"] == part_type_chunk) {
  5  |   «write-included-chunk 73d»
  6  | } else if (chunklet SUBSEP "line" in chunks) {
  7  |   «write-chunklets 74a»
  8  | } else {
  9  |   # empty last chunklet
  10  | }
     |________________________________________________________________________


To write an included chunk, we must detect any optional chunk arguments in parenthesis. Then we recurse calling write_chunk().

73d <write-included-chunk[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (match(chunklet, "^([^\\[\\(]*)\\((.*)\\)$", chunklet_parts)) {
  2  |   chunklet = chunklet_parts[1];
  3  | # hack
  4  | gsub(sprintf("%c",11), "", chunklet);
  5  | gsub(sprintf("%c",11), "", chunklet_parts[2]);
  6  |   parse_chunk_args("c-like", chunklet_parts[2], call_chunk_args, "(");
  7  |   for (c in call_chunk_args) {
  8  |     call_chunk_args[c] = expand_chunk_args(call_chunk_args[c], chunk_params, chunk_args);
  9  |   }
  10  | } else {
  11  |   split("", call_chunk_args);
  12  | }
  13  | 
  14  | write_chunk_r(chunklet, context,
  15  |             chunks[chunk_name, "part", part, "indent"] indent,
  16  |             chunks[chunk_name, "part", part, "tail"],
  17  |             chunk_path "\n         " chunk_name,
  18  |             call_chunk_args);
     |________________________________________________________________________


Before we output a chunklet of lines, we first emit the file and line number if we have one, and if it is safe to do so.
Chunklets are generally broken up by includes, so the start of a chunklet is a good place to do this. Then we output each line of the chunklet.
When it is not safe, such as in the middle of a multi-line macro definition, lineno_suppressed is set to true, and in such a case we note that we want to emit the line statement when it is next safe.

74a <write-chunklets[1](), lang=> ≡  74b▿
      ________________________________________________________________________
  1  | max_frag = chunks[chunklet, "line"];
  2  | for(frag = 1; frag <= max_frag; frag++) {
  3  |   «write-file-line 75c»
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then extract the chunklet text and expand any arguments.

74b <write-chunklets[2]() ⇑74a, lang=> +≡ ▵74a 74c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  4  | 
  5  |   text = chunks[chunklet, frag];
  6  |  
  7  |   /* check params */
  8  |   text = expand_chunk_args(text, chunk_params, chunk_args);
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If the text is a single newline (which we keep separate - see 6) then we increment the line number. In the case where this is the last line of a chunk and it is not a top-level chunk we replace the newline with an empty string --- because the chunk that included this chunk will have the newline at the end of the line that included this chunk.
We also note by newline = 1 that we have started a new line, so that indentation can be managed with the following piece of text.

74c <write-chunklets[3]() ⇑74a, lang=> +≡ ▵74b 74d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  9  | 
  10  |  if (text == "\n") {
  11  |     lineno++;
  12  |     if (part == max_part && frag == max_frag && length(chunk_path)) {
  13  |       text = "";
  14  |       break;
  15  |     } else {
  16  |       newline = 1;
  17  |     }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If this text does not represent a newline, but we see that we are the first piece of text on a newline, then we prefix our text with the current indent. 
Note 1. newline is a global output-state variable, but the indent is not. 

74d <write-chunklets[4]() ⇑74a, lang=> +≡ ▵74c 75a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  18  |   } else if (length(text) || length(tail)) {
  19  |     if (newline) text = indent text;
  20  |     newline = 0;
  21  |   }
  22  | 
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Tail will soon no longer be relevant once mode-detection is in place.

75a <write-chunklets[5]() ⇑74a, lang=> +≡ ⊲74d 75b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  23  |   text = text tail;
  24  |   mode_tracker(context, text);
  25  |   print untab(transform_escape(context, text, context_origin));
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
If a line ends in a backslash --- suggesting continuation --- then we supress outputting file-line as it would probably break the continued lines.

75b <write-chunklets[6]() ⇑74a, lang=> +≡ ▵75a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  26  |   if (linenos) {
  27  |     lineno_suppressed = substr(lastline, length(lastline)) == "\\";
  28  |   }
  29  | }
     |________________________________________________________________________


Of course there is no point in actually outputting the source filename and line number (file-line) if they don't say anything new! We only need to emit them if they aren't what is expected, or if we we not able to emit one when they had changed.

75c <write-file-line[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (newline && lineno_needed && ! lineno_suppressed) {
  2  |   filename = a_filename;
  3  |   lineno = a_lineno;
  4  |   print "#line " lineno " \"" filename "\"\n"
  5  |   lineno_needed = 0;
  6  | }
     |________________________________________________________________________


We check if a new file-line is needed by checking if the source line matches what we (or a compiler) would expect.

75d <check-source-jump[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | if (linenos && (chunk_name SUBSEP "part" SUBSEP part SUBSEP "FILENAME" in chunks)) {
  2  |   a_filename = chunks[chunk_name, "part", part, "FILENAME"];
  3  |   a_lineno = chunks[chunk_name, "part", part, "LINENO"];
  4  |   if (a_filename != filename || a_lineno != lineno) {
  5  |     lineno_needed++;
  6  |   }
  7  | }
     |________________________________________________________________________


Chapter 14Storing Chunks
Awk has pretty limited data structures, so we will use two main hashes. Uninterrupted sequences of a chunk will be stored in chunklets and the chunklets used in a chunk will be stored in chunks.

77a <constants[2]() ⇑37a, lang=> +≡ ⊲37a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  2  | part_type_chunk=1;
  3  | SUBSEP=",";
     |________________________________________________________________________


The params mentioned are not chunk parameters for parameterized chunks, as mentioned in 9.2, but the lstlistings style parameters used in the \Chunk command1. The params parameter is used to hold the parameters for parameterized chunks  ^1.

77b <chunk-storage-functions[1](), lang=> ≡  77c▿
      ________________________________________________________________________
  1  | function new_chunk(chunk_name, opts, args,
  2  |   # local vars
  3  |   p, append )
  4  | {
  5  |   # HACK WHILE WE CHANGE TO ( ) for PARAM CHUNKS
  6  |   gsub("\\(\\)$", "", chunk_name);
  7  |   if (! (chunk_name in chunk_names)) {
  8  |     if (debug) print "New chunk " chunk_name;
  9  |     chunk_names[chunk_name];
  10  |     for (p in opts) {
  11  |       chunks[chunk_name, p] = opts[p];
  12  |       if (debug) print "chunks[" chunk_name "," p "] = " opts[p];
  13  |     }
  14  |     for (p in args) {
  15  |       chunks[chunk_name, "params", p] = args[p];
  16  |     }
  17  |     if ("append" in opts) {
  18  |       append=opts["append"];
  19  |       if (! (append in chunk_names)) {
  20  |         warning("Chunk " chunk_name " is appended to chunk " append " which is not defined yet");
  21  |         new_chunk(append);
  22  |       }
  23  |       chunk_include(append, chunk_name);
  24  |       chunk_line(append, ORS);
  25  |     }
  26  |   }
  27  |   active_chunk = chunk_name;
  28  |   prime_chunk(chunk_name);
  29  | }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 

77c <chunk-storage-functions[2]() ⇑77b, lang=> +≡ ▵77b 78a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  30  | 
  31  | function prime_chunk(chunk_name)
  32  | {
  33  |   chunks[chunk_name, "part", ++chunks[chunk_name, "part"] ] = \
  34  |          chunk_name SUBSEP "chunklet" SUBSEP "" ++chunks[chunk_name, "chunklet"];
  35  |   chunks[chunk_name, "part", chunks[chunk_name, "part"], "FILENAME"] = FILENAME;
  36  |   chunks[chunk_name, "part", chunks[chunk_name, "part"], "LINENO"] = FNR + 1;
  37  | }
  38  | 
  39  | function chunk_line(chunk_name, line){
  40  |   chunks[chunk_name, "chunklet", chunks[chunk_name, "chunklet"],
  41  |          ++chunks[chunk_name, "chunklet", chunks[chunk_name, "chunklet"], "line"]  ] = line;
  42  | }
  43  | 
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Chunk include represents a chunkref statement, and stores the requirement to include another chunk. The parameter indent represents the quanity of literal text characters that preceded this chunkref statement and therefore by how much additional lines of the included chunk should be indented.

78a <chunk-storage-functions[3]() ⇑77b, lang=> +≡ ⊲77c 78b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  44  | function chunk_include(chunk_name, chunk_ref, indent, tail)
  45  | {
  46  |   chunks[chunk_name, "part", ++chunks[chunk_name, "part"] ] = chunk_ref;
  47  |   chunks[chunk_name, "part", chunks[chunk_name, "part"], "type" ] = part_type_chunk;
  48  |   chunks[chunk_name, "part", chunks[chunk_name, "part"], "indent" ] = indent_string(indent);
  49  |   chunks[chunk_name, "part", chunks[chunk_name, "part"], "tail" ] = tail;
  50  |   prime_chunk(chunk_name);
  51  | }
  52  | 
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The indent is calculated by indent_string, which may in future convert some spaces into tab characters. This function works by generating a printf padded format string, like %22s for an indent of 22, and then printing an empty string using that format.

78b <chunk-storage-functions[4]() ⇑77b, lang=> +≡ ▵78a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  53  | function indent_string(indent) {
  54  |   return sprintf("%" indent "s", "");
  55  | }
     |________________________________________________________________________


Chapter 15getopt
I use Arnold Robbins public domain getopt (1993 revision). This is probably the same one that is covered in chapter 12 of âĂĲEdition 3 of GAWK: Effective AWK Programming: A User's Guide for GNU AwkâĂİ but as that is licensed under the GNU Free Documentation License, Version 1.3, which conflicts with the GPL3, I can't use it from there (or it's accompanying explanations), so I do my best to explain how it works here.
The getopt.awk header is:

79a <getopt.awk-header[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | # getopt.awk --- do C library getopt(3) function in awk
  2  | #
  3  | # Arnold Robbins, arnold@skeeve.com, Public Domain
  4  | #
  5  | # Initial version: March, 1991
  6  | # Revised: May, 1993
  7  | 
     |________________________________________________________________________


The provided explanation is:

79b <getopt.awk-notes[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | # External variables:
  2  | #    Optind -- index in ARGV of first nonoption argument
  3  | #    Optarg -- string value of argument to current option
  4  | #    Opterr -- if nonzero, print our own diagnostic
  5  | #    Optopt -- current option letter
  6  | 
  7  | # Returns:
  8  | #    -1     at end of options
  9  | #    ?      for unrecognized option
  10  | #    <c>    a character representing the current option
  11  | 
  12  | # Private Data:
  13  | #    _opti  -- index in multi-flag option, e.g., -abc
  14  | 
     |________________________________________________________________________


The function follows. The final two parameters, thisopt and i are local variables and not parameters --- as indicated by the multiple spaces preceding them. Awk doesn't care, the multiple spaces are a convention to help us humans.

79c <getopt.awk-getopt()[1](), lang=> ≡  80a⊳
      ________________________________________________________________________
  1  | function getopt(argc, argv, options,    thisopt, i)
  2  | {
  3  |     if (length(options) == 0)    # no options given
  4  |         return -1
  5  |     if (argv[Optind] == "--") {  # all done
  6  |         Optind++
  7  |         _opti = 0
  8  |         return -1
  9  |     } else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) {
  10  |         _opti = 0
  11  |         return -1
  12  |     }
  13  |     if (_opti == 0)
  14  |         _opti = 2
  15  |     thisopt = substr(argv[Optind], _opti, 1)
  16  |     Optopt = thisopt
  17  |     i = index(options, thisopt)
  18  |     if (i == 0) {
  19  |         if (Opterr)
  20  |             printf("%c -- invalid option\n",
  21  |                                   thisopt) > "/dev/stderr"
  22  |         if (_opti >= length(argv[Optind])) {
  23  |             Optind++
  24  |             _opti = 0
  25  |         } else
  26  |             _opti++
  27  |         return "?"
  28  |     }
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
At this point, the option has been found and we need to know if it takes any arguments.

80a <getopt.awk-getopt()[2]() ⇑79c, lang=> +≡ ⊲79c
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  29  |     if (substr(options, i + 1, 1) == ":") {
  30  |         # get option argument
  31  |         if (length(substr(argv[Optind], _opti + 1)) > 0)
  32  |             Optarg = substr(argv[Optind], _opti + 1)
  33  |         else
  34  |             Optarg = argv[++Optind]
  35  |         _opti = 0
  36  |     } else
  37  |         Optarg = ""
  38  |     if (_opti == 0 || _opti >= length(argv[Optind])) {
  39  |         Optind++
  40  |         _opti = 0
  41  |     } else
  42  |         _opti++
  43  |     return thisopt
  44  | }
     |________________________________________________________________________


A test program is built in, too

80b <getopt.awk-begin[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | BEGIN {
  2  |     Opterr = 1    # default is to diagnose
  3  |     Optind = 1    # skip ARGV[0]
  4  |     # test program
  5  |     if (_getopt_test) {
  6  |         while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
  7  |             printf("c = <%c>, optarg = <%s>\n",
  8  |                                        _go_c, Optarg)
  9  |         printf("non-option arguments:\n")
  10  |         for (; Optind < ARGC; Optind++)
  11  |             printf("\tARGV[%d] = <%s>\n",
  12  |                                     Optind, ARGV[Optind])
  13  |     }
  14  | }
     |________________________________________________________________________


The entire getopt.awk is made out of these chunks in order

80c <getopt.awk[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | «getopt.awk-header 79a»
  2  | 
  3  | «getopt.awk-notes 79b»
  4  | «getopt.awk-getopt() 79c»
  5  | «getopt.awk-begin 80b»
     |________________________________________________________________________


Although we only want the header and function:

81a <getopt[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | # try: locate getopt.awk for the full original file
  2  | # as part of your standard awk installation
  3  | «getopt.awk-header 79a»
  4  | 
  5  | «getopt.awk-getopt() 79c»
     |________________________________________________________________________


Chapter 16Fangle LaTeX source code
16.1 fangle module 
Here we define a L Y X .module file that makes it convenient to use L Y X for writing such literate programs.
This file ./fangle.module can be installed in your personal .lyx/layouts folder. You will need to Tools Reconfigure so that L Y X notices it. It adds a new format Chunk, which should precede every listing and contain the chunk name.

83a <./fangle.module[1](), lang=lyx-module> ≡ 
      ________________________________________________________________________
  1  | #\DeclareLyXModule{Fangle Literate Listings}
  2  | #DescriptionBegin
  3  | #  Fangle literate listings allow one to write
  4  | #   literate programs after the fashion of noweb, but without having
  5  | #   to use noweave to generate the documentation. Instead the listings
  6  | #   package is extended in conjunction with the noweb package to implement
  7  | #   to code formating directly as latex.
  8  | #  The fangle awk script
  9  | #DescriptionEnd
  10  | 
  11  | «gpl3-copyright.hashed 83b»
  12  | 
  13  | Format 11
  14  | 
  15  | AddToPreamble
  16  | «./fangle.sty 84d»
  17  | EndPreamble
  18  | 
  19  | «chunkstyle 84a»
  20  | 
  21  | «chunkref 84c»
     |________________________________________________________________________


Because L Y X modules are not yet a language supported by fangle or lstlistings, we resort to this fake awk chunk below in order to have each line of the GPL3 license commence with a #

83b <gpl3-copyright.hashed[1](), lang=awk> ≡ 
      ________________________________________________________________________
  1  | #«gpl3-copyright 4a»
  2  | 
     |________________________________________________________________________


16.1.1 The Chunk style 
The purpose of the chunk style is to make it easier for L Y X users to provide the name to lstlistings. Normally this requires right-clicking on the listing, choosing settings, advanced, and then typing name=chunk-name. This has the further disadvantage that the name (and other options) are not generally visible during document editing.
The chunk style is defined as a LaTeX command, so that all text on the same line is passed to the LaTeX command Chunk. This makes it easy to parse using fangle, and easy to pass these options on to the listings package. The first word in a chunk section should be the chunk name, and will have name= prepended to it. Any other words are accepted arguments to lstset.
We set PassThru to 1 because the user is actually entering raw latex.

84a <chunkstyle[1](), lang=> ≡  84b▿
      ________________________________________________________________________
  1  | Style Chunk
  2  |   LatexType             Command
  3  |   LatexName             Chunk
  4  |   Margin                First_Dynamic
  5  |   LeftMargin            Chunk:xxx
  6  |   LabelSep              xx
  7  |   LabelType             Static
  8  |   LabelString           "Chunk:"
  9  |   Align                 Left
  10  |   PassThru              1
  11  | 
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
To make the label very visible we choose a larger font coloured red.

84b <chunkstyle[2]() ⇑84a, lang=> +≡ ▵84a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  12  |   LabelFont
  13  |     Family              Sans
  14  |     Size                Large
  15  |     Series              Bold
  16  |     Shape               Italic
  17  |     Color               red
  18  |   EndFont
  19  | End
     |________________________________________________________________________


16.1.2 The chunkref style 
We also define the Chunkref style which can be used to express cross references to chunks.

84c <chunkref[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | InsetLayout Chunkref
  2  |   LyxType               charstyle
  3  |   LatexType             Command
  4  |   LatexName             chunkref
  5  |   PassThru              1
  6  |   LabelFont             
  7  |     Shape               Italic
  8  |     Color               red
  9  |   EndFont
  10  | End
     |________________________________________________________________________


16.2 Latex Macros 
We require the listings, noweb and xargs packages. As noweb defines it's own \code environment, we re-define the one that L Y X logical markup module expects here.

84d <./fangle.sty[1](), lang=tex> ≡  85a⊳
      ________________________________________________________________________
  1  | \usepackage{listings}%
  2  | \usepackage{noweb}%
  3  | \usepackage{xargs}%
  4  | \renewcommand{\code}[1]{\texttt{#1}}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also define a CChunk macro, for use as: \begin{CChunk} which will need renaming to \begin{Chunk} when I can do this without clashing with \Chunk.

85a <./fangle.sty[2]() ⇑84d, lang=> +≡ ⊲84d 85b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  5  | \lstnewenvironment{Chunk}{\relax}{\relax}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also define a suitable \lstset of parameters that suit the literate programming style after the fashion of noweave.

85b <./fangle.sty[3]() ⇑84d, lang=> +≡ ▵85a 85c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  6  | \lstset{numbers=left, stepnumber=5, numbersep=5pt,
  7  |         breaklines=false,basicstyle=\ttfamily,
  8  |         numberstyle=\tiny, language=C}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also define a notangle-like mechanism for escaping to LaTeX from the listing, and by which we can refer to other listings. We declare the =<...> sequence to contain LaTeX code, and include another like this chunk: <chunkname ?>. However, because =<...> is already defined to contain LaTeX code for this document --- this is a fangle document after all --- the code fragment below effectively contains the LaTeX code: }{. To avoid problems with document generation, I had to declare an lstlistings property: escapeinside={} for this listing only; which in L Y X was done by right-clicking the listings inset, choosing settings->advanced. Therefore =< isn't interpreted literally here, in a listing when the escape sequence is already defined as shown... we need to somehow escape this representation...

85c <./fangle.sty[4]() ⇑84d, lang=> +≡ ▵85b 85d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  9  | \lstset{escapeinside={=<}{>}}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Although our macros will contain the @ symbol, they will be included in a \makeatletter section by L Y X; however we keep the commented out \makeatletter as a reminder. The listings package likes to centre the titles, but noweb titles are specially formatted and must be left aligned. The simplest way to do this turned out to be by removing the definition of \lst@maketitle. This may interact badly if other listings want a regular title or caption. We remember the old maketitle in case we need it.

85d <./fangle.sty[5]() ⇑84d, lang=> +≡ ▵85c 85e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  10  | %\makeatletter
  11  | %somehow re-defining maketitle gives us a left-aligned title
  12  | %which is extactly what our specially formatted title needs!
  13  | \global\let\fangle@lst@maketitle\lst@maketitle%
  14  | \global\def\lst@maketitle{}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
16.2.1 The chunk command 
Our chunk command accepts one argument, and calls \ltset. Although \ltset will note the name, this is erased when the next \lstlisting starts, so we make a note of this in \lst@chunkname and restore in in lstlistings Init hook.

85e <./fangle.sty[6]() ⇑84d, lang=> +≡ ▵85d 86a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  15  | \def\Chunk#1{%
  16  |   \lstset{title={\fanglecaption},name=#1}%
  17  |   \global\edef\lst@chunkname{\lst@intname}%
  18  | }%
  19  | \def\lst@chunkname{\empty}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
16.2.1.1 Chunk parameters 
Fangle permits parameterized chunks, and requires the paramters to be specified as listings options. The fangle script uses this, and although we don't do anything with these in the LaTeX code right now, we need to stop the listings package complaining.

86a <./fangle.sty[7]() ⇑84d, lang=> +≡ ⊲85e 86b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  20  | \lst@Key{params}\relax{\def\fangle@chunk@params{#1}}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
As it is common to define a chunk which then needs appending to another chunk, and annoying to have to declare a single line chunk to manage the include, we support an append= option.

86b <./fangle.sty[8]() ⇑84d, lang=> +≡ ▵86a 86c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  21  | \lst@Key{append}\relax{\def\fangle@chunk@append{#1}}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
16.2.2 The noweb styled caption 
We define a public macro \fanglecaption which can be set as a regular title. By means of \protect, It expands to \fangle@caption at the appopriate time when the caption is emitted.

86c <./fangle.sty[9]() ⇑84d, lang=> +≡ ▵86b 86d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
\def\fanglecaption{\protect\fangle@caption}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
22c ⟨some-chunk 19b⟩≡+   ⊲22b 24d⊳

In this example, the current chunk is 22c, and therefore the third chunk on page 22.
It's name is some-chunk. 
The first chunk with this name (19b) occurs as the second chunk on page 19.
The previous chunk (22d) with the same name is the second chunk on page 22.
The next chunk (24d) is the fourth chunk on page 24.

Figure 1. Noweb Heading

The general noweb output format compactly identifies the current chunk, and references to the first chunk, and the previous and next chunks that have the same name.
This means that we need to keep a counter for each chunk-name, that we use to count chunks of the same name.
16.2.3 The chunk counter 
It would be natural to have a counter for each chunk name, but TeX would soon run out of counters1. ...soon did run out of counters and so I had to re-write the LaTeX macros to share a counter as described here.  ^1, so we have one counter which we save at the end of a chunk and restore at the beginning of a chunk.

86d <./fangle.sty[10]() ⇑84d, lang=> +≡ ▵86c 87c⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  22  | \newcounter{fangle@chunkcounter}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We construct the name of this variable to store the counter to be the text lst-chunk- prefixed onto the chunks own name, and store it in \chunkcount. 
We save the counter like this:

87a <save-counter[1](), lang=> ≡ 
      ________________________________________________________________________
\global\expandafter\edef\csname \chunkcount\endcsname{\arabic{fangle@chunkcounter}}%
     |________________________________________________________________________


and restore the counter like this:

87b <restore-counter[1](), lang=> ≡ 
      ________________________________________________________________________
\setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
     |________________________________________________________________________


If there does not already exist a variable whose name is stored in \chunkcount, then we know we are the first chunk with this name, and then define a counter. 
Although chunks of the same name share a common counter, they must still be distinguished. We use is the internal name of the listing, suffixed by the counter value. So the first chunk might be something-1 and the second chunk be something-2, etc.
We also calculate the name of the previous chunk if we can (before we increment the chunk counter). If this is the first chunk of that name, then \prevchunkname is set to \relax which the noweb package will interpret as not existing.

87c <./fangle.sty[11]() ⇑84d, lang=> +≡ ⊲86d 87d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  23  | \def\fangle@caption{%
  24  |   \edef\chunkcount{lst-chunk-\lst@intname}%
  25  |   \@ifundefined{\chunkcount}{%
  26  |     \expandafter\gdef\csname \chunkcount\endcsname{0}%
  27  |     \setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
  28  |     \let\prevchunkname\relax%
  29  |   }{%
  30  |     \setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
  31  |     \edef\prevchunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  32  |   }%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
After incrementing the chunk counter, we then define the name of this chunk, as well as the name of the first chunk.

87d <./fangle.sty[12]() ⇑84d, lang=> +≡ ▵87c 87e▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  33  |   \addtocounter{fangle@chunkcounter}{1}%
  34  |   \global\expandafter\edef\csname \chunkcount\endcsname{\arabic{fangle@chunkcounter}}%
  35  |   \edef\chunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  36  |   \edef\firstchunkname{\lst@intname-1}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We now need to calculate the name of the next chunk. We do this by temporarily skipping the counter on by one; however there may not actually be another chunk with this name! We detect this by also defining a label for each chunk based on the chunkname. If there is a next chunkname then it will define a label with that name. As labels are persistent, we can at least tell the second time LaTeX is run. If we don't find such a defined label then we define \nextchunkname to \relax.

87e <./fangle.sty[13]() ⇑84d, lang=> +≡ ▵87d 88a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  37  |   \addtocounter{fangle@chunkcounter}{1}%
  38  |   \edef\nextchunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  39  |   \@ifundefined{r@label-\nextchunkname}{\let\nextchunkname\relax}{}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
The noweb package requires that we define a \sublabel for every chunk, with a unique name, which is then used to print out it's navigation hints.
We also define a regular label for this chunk, as was mentioned above when we calculated \nextchunkname. This requires LaTeX to be run at least twice after new chunk sections are added --- but noweb requried that anyway.

88a <./fangle.sty[14]() ⇑84d, lang=> +≡ ⊲87e 88b▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  40  |   \sublabel{\chunkname}%
  41  | % define this label for every chunk instance, so we
  42  | % can tell when we are the last chunk of this name
  43  |   \label{label-\chunkname}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We also try and add the chunk to the list of listings, but I'm afraid we don't do very well. We want each chunk name listing once, with all of it's references.

88b <./fangle.sty[15]() ⇑84d, lang=> +≡ ▵88a 88c▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  44  |   \addcontentsline{lol}{lstlisting}{\lst@name~[\protect\subpageref{\chunkname}]}%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
We then call the noweb output macros in the same way that noweave generates them, except that we don't need to call \nwstartdeflinemarkup or \nwenddeflinemarkup — and if we do, it messes up the output somewhat.

88c <./fangle.sty[16]() ⇑84d, lang=> +≡ ▵88b 88d▿
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  45  |   \nwmargintag{%
  46  |     {%
  47  |       \nwtagstyle{}%
  48  |       \subpageref{\chunkname}%
  49  |     }%
  50  |   }%
  51  | %
  52  |   \moddef{%
  53  |     {\lst@name}%
  54  |     {%
  55  |       \nwtagstyle{}\/%
  56  |       \@ifundefined{fangle@chunk@params}{}{%
  57  |         (\fangle@chunk@params)%
  58  |       }%
  59  |       [\csname \chunkcount\endcsname]~%
  60  |       \subpageref{\firstchunkname}%
  61  |     }%
  62  |     \@ifundefined{fangle@chunk@append}{}{%
  63  |     \ifx{}\fangle@chunk@append{x}\else%
  64  |         ,~add~to~\fangle@chunk@append%
  65  |     \fi%
  66  |     }%
  67  | \global\def\fangle@chunk@append{}%
  68  | \lstset{append=x}%
  69  |   }%
  70  | %
  71  |   \ifx\relax\prevchunkname\endmoddef\else\plusendmoddef\fi%
  72  | %  \nwstartdeflinemarkup%
  73  |   \nwprevnextdefs{\prevchunkname}{\nextchunkname}%
  74  | %  \nwenddeflinemarkup%
  75  | }%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Originally this was developed as a listings aspect, in the Init hook, but it was found easier to affect the title without using a hook — \lst@AddToHookExe{PreSet} is still required to set the listings name to the name passed to the \Chunk command, though.

88d <./fangle.sty[17]() ⇑84d, lang=> +≡ ▵88c 89a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  76  | %\lst@BeginAspect{fangle}
  77  | %\lst@Key{fangle}{true}[t]{\lstKV@SetIf{#1}{true}}
  78  | \lst@AddToHookExe{PreSet}{\global\let\lst@intname\lst@chunkname}
  79  | \lst@AddToHook{Init}{}%\fangle@caption}
  80  | %\lst@EndAspect
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
16.2.4 Cross references 
We define the \chunkref command which makes it easy to generate visual references to different code chunks, e.g.
Macro                           Appearance
\chunkref{preamble}             
\chunkref[3]{preamble}          
\chunkref{preamble}[arg1, arg2] 

Chunkref can also be used within a code chunk to include another code chunk. The third optional parameter to chunkref is a comma sepatarated list of arguments, which will replace defined parameters in the chunkref.
Note 1. Darn it, if I have: =<\chunkref{new-mode-tracker}[{chunks[chunk_name, "language"]},{mode}]> the inner braces (inside [ ]) cause _ to signify subscript even though we have lst@ReplaceIn 

89a <./fangle.sty[18]() ⇑84d, lang=> +≡ ⊲88d 90a⊳
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  81  | \def\chunkref@args#1,{%
  82  |   \def\arg{#1}%
  83  |   \lst@ReplaceIn\arg\lst@filenamerpl%
  84  |   \arg%
  85  |   \@ifnextchar){\relax}{, \chunkref@args}%
  86  | }%
  87  | \newcommand\chunkref[2][0]{%
  88  |   \@ifnextchar({\chunkref@i{#1}{#2}}{\chunkref@i{#1}{#2}()}%
  89  | }%
  90  | \def\chunkref@i#1#2(#3){%
  91  |   \def\zero{0}%
  92  |   \def\chunk{#2}%
  93  |   \def\chunkno{#1}%
  94  |   \def\chunkargs{#3}%
  95  |   \ifx\chunkno\zero%
  96  |     \def\chunkname{#2-1}%
  97  |   \else%
  98  |     \def\chunkname{#2-\chunkno}%
  99  |   \fi%
  100  |   \let\lst@arg\chunk%
  101  |   \lst@ReplaceIn\chunk\lst@filenamerpl%
  102  |   \LA{%\moddef{%
  103  |     {\chunk}%
  104  |     {%
  105  |       \nwtagstyle{}\/%
  106  |       \ifx\chunkno\zero%
  107  |       \else%
  108  |       [\chunkno]%
  109  |       \fi%
  110  |       \ifx\chunkargs\empty%
  111  |       \else%
  112  |         (\chunkref@args #3,)%
  113  |       \fi%
  114  |       ~\subpageref{\chunkname}%
  115  |     }%
  116  |   }%
  117  |   \RA%\endmoddef%
  118  | }%
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
16.2.5 The end 

90a <./fangle.sty[19]() ⇑84d, lang=> +≡ ⊲89a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  119  | %
  120  | %\makeatother
     |________________________________________________________________________


Chapter 17Extracting fangle
17.1 Extracting from Lyx 
To extract from L Y X, you will need to configure L Y X as explained in section ?.
And this lyx-build scrap will extract fangle for me.

91a <lyx-build[2]() ⇑20a, lang=sh> +≡ ⊲20a
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  11  | #! /bin/sh
  12  | set -x
  13  | 
  14  | «lyx-build-helper 19b»
  15  | cd $PROJECT_DIR || exit 1
  16  | 
  17  | /usr/local/bin/fangle -R./fangle $TEX_SRC > ./fangle
  18  | /usr/local/bin/fangle -R./fangle.module $TEX_SRC > ./fangle.module
  19  | 
  20  | export FANGLE=./fangle
  21  | export TMP=${TMP:-/tmp}
  22  | «test:* 95a»
     |________________________________________________________________________


With a lyx-build-helper

91b <lyx-build-helper[2]() ⇑19b, lang=sh> +≡ ⊲19b
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  5  | PROJECT_DIR="$LYX_r"
  6  | LYX_SRC="$PROJECT_DIR/${LYX_i%.tex}.lyx"
  7  | TEX_DIR="$LYX_p"
  8  | TEX_SRC="$TEX_DIR/$LYX_i"
  9  | TXT_SRC="$TEX_SRC"
     |________________________________________________________________________


17.2 Extracting documentation 

91c <./gen-www[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | #python -m elyxer --css lyx.css $LYX_SRC | \
  2  | #  iconv -c -f utf-8 -t ISO-8859-1//TRANSLIT | \
  3  | #  sed 's/UTF-8"\(.\)>/ISO-8859-1"\1>/' > www/docs/fangle.html
  4  | 
  5  | python -m elyxer --css lyx.css --iso885915 --html --destdirectory www/docs/fangle.e \
  6  |        fangle.lyx > www/docs/fangle.e/fangle.html
  7  | 
  8  | ( mkdir -p www/docs/fangle && cd www/docs/fangle && \
  9  |   lyx -e latex ../../../fangle.lyx && \
  10  |   htlatex ../../../fangle.tex "xhtml,fn-in" && \
  11  |   sed -i -e 's/<!--l\. [0-9][0-9]* *-->//g' fangle.html
  12  | )
  13  | 
  14  | ( mkdir -p www/docs/literate && cd www/docs/literate && \
  15  |   lyx -e latex ../../../literate.lyx && \
  16  |   htlatex ../../../literate.tex "xhtml,fn-in" && \
  17  |   sed -i -e 's/<!--l\. [0-9][0-9]* *-->$//g' literate.html
  18  | )
     |________________________________________________________________________


17.3 Extracting from the command line 
First you will need the tex output, then you can extract:

92a <lyx-build-manual[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | lyx -e latex fangle.lyx
  2  | fangle -R./fangle fangle.tex > ./fangle
  3  | fangle -R./fangle.module fangle.tex > ./fangle.module
     |________________________________________________________________________



Part III  Tests 
Chapter 18Tests

95a <test:*[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | #! /bin/bash
  2  | 
  3  | export TXT_SRC=${TXT_SRC:-fangle.txt}
  4  | export FANGLE=${FANGLE:-./fangle}
  5  | export TMP=${TMP:-/tmp}
  6  | 
  7  | tm -s -c fangle.tm fangle.txt -q
  8  | 
  9  | «test:helpers 95c»
  10  | «test:run-tests 95b»
  11  | # Now check that we can extract a fangle that also passes the tests!
  12  | $FANGLE -R./fangle $TXT_SRC > ./fangle.new
  13  | export FANGLE=./fangle.new
  14  | «test:run-tests 95b»
     |________________________________________________________________________



95b <test:run-tests[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | # run tests
  2  | $FANGLE -Rpca-test.awk $TXT_SRC | awk -f - || exit 1
  3  | «test:cromulence 54g»
  4  | «test:escapes 59a»
  5  | «test:test-chunk(test:example-sh, test:example-sh.result) ?a»
  6  | «test:test-chunk(test:example-makefile, test:example-makefile.result) ?a»
  7  | «test:chunk-params 97e»
     |________________________________________________________________________



95c <test:helpers[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | passtest() {
  2  |   if "$@"
  3  |   then echo "Passed $TEST"
  4  |   else echo "Failed $TEST"
  5  |        return 1
  6  |   fi
  7  | }
  8  | 
  9  | failtest() {
  10  |   if ! "$@"
  11  |   then echo "Passed $TEST"
  12  |   else echo "Failed $TEST"
  13  |        return 1
  14  |   fi
  15  | }
     |________________________________________________________________________


This chunk will render a named chunk and compare it to another rendered nameed chunk

?a <test:test-chunk[1](chunk, result), lang=sh> ≡ 
      ________________________________________________________________________
  1  | TEST="${result}" passtest diff -u --label "${chunk}" <( $FANGLE -R${chunk} $TXT_SRC ) \
  2  |                                  --label "${result}" <( $FANGLE -R${result} $TXT_SRC )
     |________________________________________________________________________


Chapter 19Chunk Parameters
19.1 L Y X 

97a <test:lyx:chunk-params:sub[1](THING, colour), lang=> ≡ 
      ________________________________________________________________________
  1  | I see a ${THING},
  2  | a ${THING} of colour ${colour}, 
  3  | and looking closer =<\chunkref{test:lyx:chunk-params:sub:sub}(${colour})>
     |________________________________________________________________________



97b <test:lyx:chunk-params:sub:sub[1](colour), lang=> ≡ 
      ________________________________________________________________________
  1  | a funny shade of ${colour}
     |________________________________________________________________________



97c <test:lyx:chunk-params:text[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | What do you see? "=<\chunkref{test:lyx:chunk-params:sub}(joe, red)>"
  2  | Well, fancy!
     |________________________________________________________________________


Should generate output:

97d <test:lyx:chunk-params:result[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | What do you see? "I see a joe,
  2  |                   a joe of colour red, 
  3  |                   and looking closer a funny shade of red"
  4  | Well, fancy!
     |________________________________________________________________________


And this chunk will perform the test:

97e <test:chunk-params[1](), lang=> ≡  98c⊳
      ________________________________________________________________________
  1  | «test:test-chunk(test:lyx:chunk-params:text, test:lyx:chunk-params:result) ?a» || exit 1
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
19.2 TeXmacs 

97f <test:chunk-params:sub[1](THING, colour), lang=> ≡ 
      ________________________________________________________________________
  1  | I see a ${THING},
  2  | a ${THING} of colour ${colour}, 
  3  | and looking closer «test:chunk-params:sub:sub(${colour}) 97g»
     |________________________________________________________________________



97g <test:chunk-params:sub:sub[1](colour), lang=> ≡ 
      ________________________________________________________________________
  1  | a funny shade of ${colour}
     |________________________________________________________________________



98a <test:chunk-params:text[1](), lang=> ≡  96a⊳
      ________________________________________________________________________
  1  | What do you see? "«test:chunk-params:sub(joe, red) 97f»"
  2  | Well, fancy!
     |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ 
Should generate output:

98b <test:chunk-params:result[1](), lang=> ≡ 
      ________________________________________________________________________
  1  | What do you see? "I see a joe,
  2  |                   a joe of colour red, 
  3  |                   and looking closer a funny shade of red"
  4  | Well, fancy!
     |________________________________________________________________________


And this chunk will perform the test:

98c <test:chunk-params[2]() ⇑97e, lang=> +≡ ⊲97e
     ./\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
  2  | «test:test-chunk(test:chunk-params:text, test:chunk-params:result) ?a» || exit 1
     |________________________________________________________________________


Chapter 20Compile-log-lyx

99a <Chunk:./compile-log-lyx[1](), lang=sh> ≡ 
      ________________________________________________________________________
  1  | #! /bin/sh
  2  | # can't use gtkdialog -i, cos it uses the "source" command which ubuntu sh doesn't have
  3  | 
  4  | main() {
  5  |   errors="/tmp/compile.log.$$"
  6  | #  if grep '^[^ ]*:\( In \|[0-9][0-9]*: [^ ]*:\)' > $errors
  7  | if grep '^[^ ]*(\([0-9][0-9]*\)) *: *\(error\|warning\)' > $errors
  8  |   then
  9  |     sed -i -e 's/^[^ ]*[/\\]\([^/\\]*\)(\([ 0-9][ 0-9]*\)) *: */\1:\2|\2|/' $errors
  10  |     COMPILE_DIALOG='
  11  |  <vbox>
  12  |   <text>
  13  |     <label>Compiler errors:</label>
  14  |   </text>
  15  |   <tree exported_column="0">
  16  |     <variable>LINE</variable>
  17  |     <height>400</height><width>800</width>
  18  |     <label>File | Line | Message</label>
  19  |     <action>'". $SELF ; "'lyxgoto $LINE</action>
  20  |     <input>'"cat $errors"'</input>
  21  |   </tree>
  22  |   <hbox>
  23  |    <button><label>Build</label>
  24  |      <action>lyxclient -c "LYXCMD:build-program" &</action>
  25  |    </button>
  26  |    <button ok></button>
  27  |   </hbox>
  28  |  </vbox>
  29  | '
  30  |     export COMPILE_DIALOG
  31  |     ( gtkdialog --program=COMPILE_DIALOG ; rm $errors ) &
  32  |   else
  33  |     rm $errors
  34  |   fi
  35  | }
  36  | 
  37  | lyxgoto() {
  38  |   file="${LINE%:*}"
  39  |   line="${LINE##*:}"
  40  |   extraline=‘cat $file | head -n $line | tac | sed '/^\\\\begin{lstlisting}/q' | wc -l‘
  41  |   extraline=‘expr $extraline - 1‘
  42  |   lyxclient -c "LYXCMD:command-sequence server-goto-file-row $file $line ; char-forward ; repeat $extraline paragraph-down ; paragraph-up-select"
  43  | }
  44  | 
  45  | SELF="$0"
  46  | if test -z "$COMPILE_DIALOG"
  47  | then main "$@" 
  48  | fi
     |________________________________________________________________________


