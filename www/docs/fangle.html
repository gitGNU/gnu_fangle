<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2010-01-23"/>
<link rel="stylesheet" href="lyx.css" type="text/css" media="screen"/>
<title>fangle</title>
</head>
<body>
<div id="globalWrapper">

<h1 class="title">
fangle
</h1>
<h2 class="author">
Sam Liddicott
</h2>
<h2 class="Date">
August 2009
</h2>
<h1 class="Chapter-">
<a class="toc" name="toc-Chapter*-1"></a>Introduction
</h1>
<div class="Standard">
<span class="versalitas">Fangle</span> is a tool for fangled literate programming. Newfangled is defined as <i>New and often needlessly novel</i> by <span class="versalitas">TheFreeDictionary.com</span>.
</div>
<div class="Standard">
In this case, fangled means yet another new and improved method for literate programming.
</div>
<div class="Standard">
<span class="versalitas">Literate Programming</span> has a long history starting with the great <span class="versalitas">Donald Knuth</span> himself, whose literate programming tools seem to make use of as many escape sequences for semantic markup as TeX itself.
</div>
<div class="Standard">
<span class="versalitas">Norman Ramsey</span> wrote the <span class="versalitas">noweb</span> set of tools (notangle, noweave and noroots) and helpfully reduced the amount of magic character sequences to pretty much just 
<span class="code">
&lt;&lt;
</span> and 
<span class="code">
@
</span>, and in doing so brought the wonders of literate programming within my reach.
</div>
<div class="Standard">
While using the LyX editor for LaTeX editing I had various troubles with the noweb tools, some of which were my fault, some of which were noweb's fault and some of which were LyX's fault.
</div>
<div class="Standard">
<span class="versalitas">Noweb</span> generally brought literate programming to the masses through removing some of the complexity of the original literate programming, but this would be of no advantage to me if the LyX / LaTeX combination brought more complications in their place.
</div>
<div class="Standard">
<span class="versalitas">Fangle</span> was thus born --- as an awk replacement for notangle, adding some important features, like better integration with LyX and LaTeX, multiple output format conversions, and fixing notangle bugs like indentation when using -L for line numbers.
</div>
<div class="Standard">
Significantly, fangle is just one program which replaces various programs in Noweb. Noweave is done away with and implemented directly as LaTeX macros, and noroots is implemented as a function of the untangler <span class="versalitas">newfangle</span>.
</div>
<div class="Standard">
Fangle is written in awk for portability reasons, awk being available for most platforms. A python conversion will probably be attempted for the benefit of LyX. (Hasn't anyone implemented awk in python yet?)
</div>
<div class="Standard">
As an extension to many literate-programming styles, Fangle permits code chunks to take parameters and thus operate somewhat like C pre-processor macros, or like C++ templates.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section*-1"></a>Todo
</h2>
<ol>

<li>
^^ is always going to be a problem, see texbytopic 1.2.2 (Work out what I meant by this).
</li>
<li>
copy over up to date Makefile guide from noweb-lyx document
</li>
<li>
Make chunk-name settings only apply to chunks with that name
</li>
<li>
indent of multi-line chunks may be mode dependant (i.e. not in string literals)
</li>
<li>
add support for other commands in =&lt;...&gt;, starting with \label which takes the line-number within the chunk, and maybe should also take the chunk name/page
</li>
<li>
cant have listing inside a ruled box
</li>
<li>
when a parameterized chunk is included as well as the #line emission, say what the paremeters were for that invocation.
</li>
<li>
\chunkref[3]{preamble} to include a certain chunk needs to work in fangle.awk instead of failing to be recognized at all
</li>
<li>
make in-listins labels track the chunk ref too, and make \chunref{[2],thing}&gt; resolve to 41c (or d, or whatever chunk the 2nd chunk of thing is
</li>
<li>
\chunkref in text needs a trailing space maybe, it keeps butting up to the next word
</li>
<li>
because the white-space indent is output by the parent chunk, the #line is that of the parent chunk. White space indents must be passed to the child chunk
</li>
</ol>
<h1 class="Chapter-">
<a class="toc" name="toc-Chapter*-2"></a>License
</h1>
<div class="Standard">
<a class="Label" name="cha:License"> </a>Fangle is licensed under the GPL 3<sup><a class="bibliocite" name="cite-1" href="#biblio-1">1</a></sup> (or later). This doesn't mean that you can't use or distribute fangle with sources of an incompatible license, but it means you must make the source of newfangle available too.
</div>
<div class="Chunk">
gpl3-copyright,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">fangle - fully featured notangle replacement in awk

Copyright (C) Sam Liddicott 2009

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</code>
</div>
</div>
</div>
<div class="Standard">

<div class="fulltoc">

<div class="tocheader">
Table of Contents
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Chapter*-1">Chapter: Introduction</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section*-1">Section: Todo</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Chapter*-2">Chapter: License</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Part-1">Part 1: Using Fangle</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Chapter-1">Chapter 1: Running Fangle</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-1.1">Section 1.1: Listing roots</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.2">Section 1.2: Extracting roots</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.3">Section 1.3: Formatting source in LaTeX</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Chapter-2">Chapter 2: Literate Programming with Fangle</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-3">Chapter 3: Using Fangle with LyX</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-3.1">Section 3.1: Setting up Lyx</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.1">Subsection 3.1.1: Installing the LyX module</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.2">Subsection 3.1.2: Configuring the build script</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.3">Subsection 3.1.3: Preparing your Lyx document</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsubsection-3.1.3.1">Subsubsection 3.1.3.1: Customising the listing appearance</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection-3.1.3.2">Subsubsection 3.1.3.2: Global customisations</a>
</div></div>
</div>
</div>

<div class="toc">
<a class="Link" href="#toc-Chapter-4">Chapter 4: Fangle with Makefiles</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-4.1">Section 4.1: A word about makefiles formats</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.2">Section 4.2: Boot-strapping the extraction</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.1">Subsection 4.2.1: Using a Makefile</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.2">Subsection 4.2.2: ...</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-4.3">Section 4.3: Extracting Sources</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.1">Subsection 4.3.1: Including Makefile.inc</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.2">Subsection 4.3.2: Recursive use of Makefile.inc</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.3">Subsection 4.3.3: Converting from Lyx to LaTeX</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.4">Subsection 4.3.4: Extracting Program Source</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.5">Subsection 4.3.5: Extracting C sources</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.6">Subsection 4.3.6: Extracting Documentation</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsubsection-4.3.6.1">Subsubsection 4.3.6.1: Running pdflatex</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection-4.3.6.2">Subsubsection 4.3.6.2: The docs as a whole</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.7">Subsection 4.3.7: Other helpers</a>
</div></div>
</div>
</div>

<div class="toc">
<a class="Link" href="#toc-Part-2">Part 2: Source Code</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Chapter-5">Chapter 5: Fangle awk source code</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-5.1">Section 5.1: AWK tricks</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.2">Section 5.2: Catching errors</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Chapter-6">Chapter 6: lstlistings</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-6.1">Section 6.1: Additional lstlstings parameters</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.2">Section 6.2: Parsing chunk arguments</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.3">Section 6.3: Expanding parameters in the text</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Chapter-7">Chapter 7: Language Modes</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-7.1">Section 7.1: Modes</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.1">Subsection 7.1.1: Modes to keep code together</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.2">Subsection 7.1.2: Modes to included chunks</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-7.2">Section 7.2: Language Mode Definitions</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.1">Subsection 7.2.1: Backslash</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.2">Subsection 7.2.2: Strings</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.3">Subsection 7.2.3: Parentheses, Braces and Brackets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.4">Subsection 7.2.4: Customizing Standard Modes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.5">Subsection 7.2.5: Comments</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-7.3">Section 7.3: Some tests</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.4">Section 7.4: A non-recursive mode tracker</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.1">Subsection 7.4.1: Constructor</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.2">Subsection 7.4.2: Management</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.3">Subsection 7.4.3: Tracker</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsubsection-7.4.3.1">Subsubsection 7.4.3.1: One happy chunk</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsubsection-7.4.3.2">Subsubsection 7.4.3.2: Tests</a>
</div></div>
</div>

<div class="toc">
<a class="Link" href="#toc-Section-7.5">Section 7.5: Escaping and Quoting</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Chapter-8">Chapter 8: Recognizing Chunks</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-8.1">Section 8.1: Chunk start</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.1">Subsection 8.1.1: lstlistings</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.2">Subsection 8.1.2: Noweb</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-8.2">Section 8.2: Chunk end</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.1">Subsection 8.2.1: lstlistings</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.2">Subsection 8.2.2: noweb</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-8.3">Section 8.3: Chunk contents</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-8.3.1">Subsection 8.3.1: lstlistings</a>
</div></div>
</div>

<div class="toc">
<a class="Link" href="#toc-Chapter-9">Chapter 9: Processing Options</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-10">Chapter 10: Generating the output</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-10.1">Section 10.1: Assembling the chunks</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-10.1.1">Subsection 10.1.1: Chunk parts</a>
</div></div>
</div>

<div class="toc">
<a class="Link" href="#toc-Chapter-11">Chapter 11: Storing chunks</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-12">Chapter 12: getopt</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-13">Chapter 13: Fangle LaTeX source code</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-13.1">Section 13.1: fangle module</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-13.1.1">Subsection 13.1.1: The Chunk style</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-13.1.2">Subsection 13.1.2: The chunkref style</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Section-13.2">Section 13.2: Latex Macros</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsection-13.2.1">Subsection 13.2.1: The chunk command</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Subsubsection-13.2.1.1">Subsubsection 13.2.1.1: Chunk parameters</a>
</div></div>

<div class="toc">
<a class="Link" href="#toc-Subsection-13.2.2">Subsection 13.2.2: The noweb styled caption</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-13.2.3">Subsection 13.2.3: The chunk counter</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-13.2.4">Subsection 13.2.4: Cross references</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-13.2.5">Subsection 13.2.5: The end</a>
</div></div>
</div>

<div class="toc">
<a class="Link" href="#toc-Chapter-14">Chapter 14: Extracting fangle</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Section-14.1">Section 14.1: Extracting from Lyx</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-14.2">Section 14.2: Extracting documentation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-14.3">Section 14.3: Extracting from the command line</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-14.4">Section 14.4: Testing</a>
</div></div>
</div>

<div class="toc">
<a class="Link" href="#toc-Part-3">Part 3: Tests</a>
</div><div class="tocindent">

<div class="toc">
<a class="Link" href="#toc-Chapter-15">Chapter 15: Chunk Parameters</a>
</div></div>

</div>
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-1">Part 1.</a> Using Fangle
</h1>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> Running Fangle
</h1>
<div class="Standard">
Fangle is a replacement for noweb, which consists of 
<span class="code">
notangle
</span>, 
<span class="code">
noroots
</span> and 
<span class="code">
noweave
</span>.
</div>
<div class="Standard">
Like 
<span class="code">
notangle
</span> and 
<span class="code">
noroots
</span> it can read multiple named files, or from stdin.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.1">1.1</a> Listing roots
</h2>
<div class="Standard">
The -r option causes fangle to behave like noroots.
</div>
<pre class="LyX-Code">
fangle -r filename.tex
</pre>
<div class="Standard">
will print out the fangle roots of a tex file. 
</div>
<div class="Standard">
Unlike the 
<span class="code">
noroots
</span> command, the roots are not enclosed in 
<span class="code">
&lt;&lt;name&gt;&gt;
</span>, unless at least one of the roots is defined using the 
<span class="code">
notangle
</span> style 
<span class="code">
&lt;&lt;name&gt;&gt;=
</span>.
</div>
<div class="Standard">
Also, unlike noroots, it prints out all roots --- not just those that are not used elsewhere. I find that a root not being used, doesn't make it particularly top level. My convention is that top level roots to be extracted begin with 
<span class="code">
./
</span> and have the form of a filename.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.2">1.2</a> Extracting roots
</h2>
<div class="Standard">
notangle's 
<span class="code">
-R
</span> and 
<span class="code">
-L
</span> options are supported.
</div>
<div class="Standard">
The standard way to extract a file would be:
</div>
<pre class="LyX-Code">
fangle -R./Makefile.inc newfangle.tex &gt; ./Makefile.inc
</pre>
<div class="Standard">
Unlike the 
<span class="code">
noroots
</span> command, the 
<span class="code">
-L
</span> option does not break indenting; also the 
<span class="code">
-L
</span> option does not interrupt (and break) multi-line C macros --- or indeed any line ending with a backslash. This does mean that sometimes the compiler might calculate the source line wrongly when generating error messages in such cases, but there isn't any other way around if multi-line macros include other chunks.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.3">1.3</a> Formatting source in LaTeX
</h2>
<div class="Standard">
The noweave replacement is a set of LaTeX macros dependant upon <i>noweb.sty</i>, and which can be included with:
</div>
<pre class="LyX-Code">
\usepackage{fangle.sty}
</pre>
<div class="Standard">
The LaTeX macros are shown in section <a class="Reference" href="#sec:Latex-Macros">13.2?</a>, and are part of a LyX module file 
<span class="code">
fangle.module
</span>, which automatically includes the macros in the document pre-amble when the fangle LyX module is used.
</div>
<div class="Standard">
Because the noweave replacement is impemented in LaTeX, there is no processing stage required before running the 
<span class="code">
latex
</span> command. LaTeX may need running two or more times, so that the code chunk references can be fully calculated.
</div>
<div class="Standard">
The 
<span class="code">
noweb.sty
</span> package is required as it is used for formatting the code chunk captions
</div>
<div class="Standard">
The 
<span class="code">
listings.sty
</span> package is also required, as it is used for formatting the code chunks themselves.
</div>
<div class="Standard">
The 
<span class="code">
xargs.sty
</span> package is also required.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> Literate Programming with Fangle
</h1>
<div class="Standard">
Todo. Should really follow on from a part-0 explanation of what literate programming is.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-3">3</a> Using Fangle with LyX
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-3.1">3.1</a> Setting up Lyx
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.1">3.1.1</a> Installing the LyX module
</h3>
<div class="Standard">
Copy 
<span class="code">
fangle.module
</span> to your LyX layouts directory, which for unix users will be 
<span class="code">
~/.lyx/layouts
</span>
</div>
<div class="Standard">
You will need to reconfigure LyX by clicking Tools&nbsp;?&nbsp;Reconfigure, and then re-start LyX.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.2">3.1.2</a> <a class="Label" name="sub:Configuring-the-build"> </a>Configuring the build script
</h3>
<div class="Standard">
Make sure you don't have a conversion defined for Lyx -> Program
</div>
<div class="Standard">
From the menu Tools&nbsp;?&nbsp;Preferences, add a conversion from Latex(Plain) -> Program as:
</div>
<pre class="LyX-Code">
set -x ; fangle -Rlyx-build $$i | 
</pre>
<pre class="LyX-Code">
  env LYX_b=$$b LYX_i=$$i LYX_o=$$o LYX_p=$$p LYX_r=$$r bash
</pre>
<div class="Standard">
(But don't cut-n-paste it from this document or you'll be pasting a multi-line string which will break your lyx preferences file). 
</div>
<div class="Standard">
I hope that one day, LyX will set these into the environment when calling the build script.
</div>
<div class="Standard">
You may also want to consider adding options to this conversion...
</div>
<pre class="LyX-Code">
parselog=/usr/share/lyx/scripts/listerrors
</pre>
<div class="Standard">
...but if you do you will lose your stderr<span class="FootMarker"> [A->] </span>
<span class="Foot">
<span class="FootMarker">[->A] </span>There is some bash plumbing to get a copy of stderr but this footnote is too small
</span>.
</div>
<div class="Standard">
Now, a shell script chunk called 
<span class="code">
lyx-build
</span> will be extracted and run whenever you choose the Document&nbsp;?&nbsp;Build Program menu item.
</div>
<div class="Standard">
The lyx-build script for this document is in section <a class="Reference" href="#lyx-build-script">?</a> and on a unix system will extract 
<span class="code">
fangle.module
</span> and the 
<span class="code">
fangle
</span> awk script.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.3">3.1.3</a> Preparing your Lyx document
</h3>
<div class="Standard">
It is not necessary to base your literate document on any of the original LyX literate classes; so select a regular class for your document type.
</div>
<div class="Standard">
Add the new module <i>Fangle Literate</i> <i>Listings</i> and possibly also <i>Logical Markup</i>.
</div>
<div class="Standard">
In the drop-down style listbox you should notice a new style defined, called <i>Chunk</i>.
</div>
<div class="Standard">
When you wish to insert a literate chunk, you enter it's plain name in the Chunk style, instead of the older method that used 
<span class="code">
&lt;&lt;name&gt;&gt;=
</span> type tags. Following the chunk name, you insert a listing with: Insert&nbsp;?&nbsp;Program Listing.
</div>
<div class="Standard">
Inside the white listing box you can type (or paste using shift+ctrl+V) your listing. There is not need to use ctrl+enter at the end of lines as with some older LyX literate techniques --- just press enter as normal.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.1.3.1">3.1.3.1</a> Customising the listing appearance
</h4>
<div class="Standard">
In the final document, the code is formatted using the <span class="versalitas">lstlistings</span> package. The chunk style doesn't just define the chunk name, but can also define any other chunk options supported by the lstlistings package 
<span class="code">
\lstset
</span> command. In fact, what you type in the chunk style is raw latex. If you want to set the chunk language without having to right-click the listing, just add 
<span class="code">
,lanuage=C
</span> after the chunk name.
</div>
<div class="Standard">
Of course you can do this by editing the listings box advanced properties by right-clicking on the listings box, but that takes longer, and you can't see at-a-glance what the advanced settings are while editing the document; also advanced settings apply only to that box --- the chunk settings apply through the rest of the document<span class="FootMarker"> [B->] </span>
<span class="Foot">
<span class="FootMarker">[->B] </span>It ought to apply only to subsequent chunks of the same name. I'll fix that later
</span>.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3.1.3.2">3.1.3.2</a> Global customisations
</h4>
<div class="Standard">
As <i>lstlistings</i> is used to set the code chunks, it's 
<span class="code">
\lstset
</span> command can be used in the pre-amble to set some document wide settings.
</div>
<div class="Standard">
If your source has many words with long sequences of capital letters, then 
<span class="code">
columns=fullflexible
</span> may be a good idea, or the capital letters will get crowded. (I think lstlistings ought to use a slightly smaller font for captial letters so that they still fit).
</div>
<div class="Standard">
The font family 
<span class="code">
\ttfamily
</span> looks more normal for code, but has no bold (unless luximono is used, but it doesn't work for me); so I use 
<span class="code">
\color{darkgreen}
</span> for my keywords. With 
<span class="code">
\ttfamily
</span>, 
<span class="code">
columns=fullflexible
</span> is used or the wrong letter spacing is used.
</div>
<div class="Standard">
In my LeTeX pre-amble I usually specialise my code format with:
</div>
<div class="Chunk">
document-preamble,language=tex
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\usepackage{xcolor}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\lstset{numbers=left, stepnumber=5, numbersep=5pt, breaklines=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{darkgreen},
  numberstyle=\tiny,language=C,columns=fullflexible,
  numberfirstline=true
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-4">4</a> Fangle with Makefiles
</h1>
<div class="Standard">

<span class="greyedout">
This chapter needs revising
</span>Here we describe a Makefile.inc that you can include in your own Makefiles, or glue as a recursive make to other projects.
</div>
<div class="Standard">
The Makefile.inc described here was put together for a Samba4 vfs module, but can be used in any Make project, including automake projects.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.1">4.1</a> A word about makefiles formats
</h2>
<div class="Standard">
Whitespace formatting is very important in a Makefile. The first character of each command line must be a TAB.
</div>
<pre class="LyX-Code">
target: pre-requisite<br/>
   ->    action<br/>
   ->    action
</pre>
<div class="Standard">
But a TAB is pretty hard to enter into most of the Lyx formats and insets I've been using. An alternative is to use a semi-colon after the pre-requisite, and a backslash at the end of each line (except the last). Then any whitespace (or none) can prefix each action.
</div>
<pre class="LyX-Code">
target: pre-requisite ; \<br/>
__action \<br/>
__action
</pre>
<div class="Standard">
This is the style that we use and it works pretty well for GNU make at least.
</div>
<div class="Standard">
We also adopt a convention that code chunks whose names beginning with ./ should always be automatically extracted from the document. Code chunks whose names do not begin with ./ are for internal reference. (This doesn't prevent such chunks from being extracted directly).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.2">4.2</a> Boot-strapping the extraction
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.1">4.2.1</a> Using a Makefile
</h3>
<div class="Standard">
<a class="Label" name="sub:Bootstrap-Using-a-Makefile"> </a>It seems convenient to have the makefile extract or update the C source files as part of it's operation. It also seems convenient to have the makefile itself extracted from this document.
</div>
<div class="Standard">
It would also be convenient to have the code to extract the makefile from this document to also be part of this document, however we have to start somewhere and this unfortunately requires us to type at least a few words by hand to start things off.
</div>
<div class="Standard">
Therefore we will have a minimal root fragment, which, when extracted, can cope with extracting the rest of the source. perhaps with this shell script, which could be called <i>autoboot</i>.
</div>
<div class="Chunk">
*
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">#! /bin/sh

MAKE_SRC="${1:-${NW_LYX:-../../noweb-lyx/noweb-lyx3.lyx}}"
MAKE_SRC='dirname "$MAKE_SRC"'/'basename "$MAKE_SRC" .lyx'
NOWEB_SRC="${2:-${NOWEB_SRC:-$MAKE_SRC.lyx}}"
lyx -e latex $MAKE_SRC

fangle -R./Makefile.inc ${MAKE_SRC}.tex \
  | sed "/FANGLE_SOURCE=/s/^/#/;T;aNOWEB_SOURCE=$NEWFANGLE_SRC" \
  | cpif ./Makefile.inc

make -f ./Makefile.inc fangle_sources
</code>
</div>
</div>
</div>
<div class="Standard">
The general Makefile can be invoked with <i>./autoboot</i> and can also be included into any automake file to automatically re-generate the source files.
</div>
<div class="Standard">
The <i>autoboot</i> can be extracted with this command:
</div>
<pre class="LyX-Code">
lyx -e latex fangle.lyx &amp;&amp; \
</pre>
<pre class="LyX-Code">
fangle newfangle.lyx &gt; ./autoboot
</pre>
<div class="Standard">
This looks simple enough, but as mentioned, fangle has to be had from somewhere before it can be extracted.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.2">4.2.2</a> ...
</h3>
<div class="Standard">
When the lyx-build chunk is executed, the current directory will be a temporary directory, and 
<span class="code">
LYX_SOURCE
</span> will refer to the tex file in this temporary directory. This is unfortunate as our makefile wants to run from the project directory where the Lyx file is kept.
</div>
<div class="Standard">
We can extract the project directory from $$r, and derive the probable Lyx filename from the noweb file that Lyx generated.
</div>
<div class="Chunk">
lyx-build-helper
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">PROJECT_DIR="$LYX_r"
LYX_SRC="$PROJECT_DIR/${LYX_i%.tex}.lyx"
TEX_DIR="$LYX_p"
TEX_SRC="$TEX_DIR/$LYX_i"
</code>
</div>
</div>
</div>
<div class="Standard">
And then we can define a lyx-build fragment similar to the autoboot fragment
</div>
<div class="Chunk">
lyx-build
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">#! /bin/sh
=&lt;\chunkref{lyx-build-helper}&gt;
cd $PROJECT_DIR || exit 1

#/usr/bin/fangle -filter ./notanglefix-filter \
#  -R./Makefile.inc "../../noweb-lyx/noweb-lyx3.lyx" \
#  | sed '/NOWEB_SOURCE=/s/=.*/=samba4-dfs.lyx/' \
#  &gt; ./Makefile.inc
#
#make -f ./Makefile.inc fangle_sources
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.3">4.3</a> Extracting Sources
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.1">4.3.1</a> Including Makefile.inc
</h3>
<div class="Standard">
<a class="Label" name="sub:Keeping-extracted-files"> </a>Makefile.inc will cope with extracting all the other source files from this document and keeping them up to date. 
</div>
<div class="Standard">
It may also be included by a Makefile or Makefile.am defined in a Lyx document to automatically deal with the extraction of source files and documents.
</div>
<div class="Standard">
A makefile has two parts; variables must be defined before the targets that use them.
</div>
<div class="Chunk">
./Makefile.inc
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{Makefile.inc-vars}&gt;
=&lt;\chunkref{Makefile.inc-targets}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We first define 
<span class="code">
NOWEB_SOURCE
</span> to hold the name of this Lyx file.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">LYX_SOURCE=
LITERATE_SOURCE=$(LYX_SOURCE)
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.2">4.3.2</a> Recursive use of Makefile.inc
</h3>
<div class="Standard">
The makefile glue described here is used when building Samba4 vfs modules.
</div>
<div class="Standard">
If you are defining a module of an existing program you may find it easier to use a slight recursive make instead of including the makefile directly. This way there is less chance of definitions in Makefile.inc interfering with definitions in the main makefile, or with definitions in other Makefile.inc from other noweb modules.
</div>
<div class="Standard">
The glue works by adding a .PHONY target to call the recursive make, and adding this target as an additional pre-requisite to the existing targets.
</div>
<div class="Standard">
In this example, the existing build system already has a build target for 
<span class="code">
example.o
</span>, so we just add another pre-requisite to that. In this case we use 
<span class="code">
example.tex.stamp
</span> as a pre-requisite, the stamp file's modified time indicating when all sources were extracted.
</div>
<div class="Chunk">
makefile-glue
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(example_srcdir)/example.o: $(example_srcdir)/example.tex.stamp
</code>
</div>
</div>
</div>
<div class="Standard">
The target for this new pre-requisite is generated by a recursive make using Makefile.inc which will make sure that the source is up to date, before it is built by the main projects makefile.
</div>
<div class="Chunk">
makefile-glue
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(example_srcdir)/example.tex.stamp: $(example_srcdir)/example.tex ; \
        cd $(example_srcdir) &amp;&amp; \
        $(MAKE) -f Makefile.inc fangle_sources
</code>
</div>
</div>
</div>
<div class="Standard">
We can do similar glue for the docs, clean and distclean targets. In this example our build system is using a double colon for these targets, so we use the same in our glue.
</div>
<div class="Chunk">
makefile-glue
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">docs:: docs_example
.PHONY: docs_example
docs_example:: ; cd $(example_srcdir) &amp;&amp; \
        $(MAKE) -f Makefile.inc docs

clean:: clean_example
.PHONEY: clean_example
clean_example: ; cd $(example_srcdir) &amp;&amp; \
        $(MAKE) -f Makefile.inc clean

distclean:: distclean_example
.PHONY: distclean_example
distclean_example: ; cd $(example_srcdir) &amp;&amp; \
        $(MAKE) -f Makefile.inc distclean
</code>
</div>
</div>
</div>
<div class="Standard">
We could do similarly for install targets to install the generated docs.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.3">4.3.3</a> <a class="Label" name="sub:Converting-from-Lyx"> </a>Converting from Lyx to LaTeX
</h3>
<div class="Standard">
The first stage will always be to convert the Lyx file to a LaTeX file; this must be so not only because fangle needs to to run on a TeX file, but also because the Lyx command <i>server-goto-file-line<span class="FootMarker"> [C->] </span>
<span class="Foot">
<span class="FootMarker">[->C] </span>The Lyx command <i>server-goto-file-line</i> is used to position the Lyx cursor at the compiler errors.
</span></i> insists that the line number provided is a line in the TeX file, and always reverse maps this to derive the line in the Lyx docment.
</div>
<div class="Standard">
The command [[lyx -e literate noweb-lyx.lyx]] will produce [[noweb-lyx.nw]] a tex file, so we define the noweb target to be the same as the Lyx file but with the .nw extension.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">TEX_SOURCE=$(LYX_SOURCE:.lyx=.tex)
</code>
</div>
</div>
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(TEX_SOURCE): $(LYX_SOURCE) ;\
        lyx -e latex $&lt;
clean_tex: ; rm -f -- $(TEX_SOURCE)
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.4">4.3.4</a> Extracting Program Source
</h3>
<div class="Standard">
The program source is extracted using fangle, which is designed to operate on a LaTeX document. 
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">FANGLE_SOURCE=$(TEX_SOURCE)
</code>
</div>
</div>
</div>
<div class="Standard">
The Lyx document can result in any number of source documents, but not all of these will be changed each time the Lyx document is updated. We certainly don't want to update the timestamps of these files and cause the whole source tree to be recompiled just because the Lyx document was edited. 
</div>
<div class="Standard">
To solve this problem we use a stamp file which is always updated each time the sources are extracted from the LaTeX document. If the stamp file is older than the LaTeX document, then we can make an attempt to re-extract the sources.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">FANGLE_SOURCE_STAMP=$(NEWFANGLE_SOURCE).stamp
</code>
</div>
</div>
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(FANGLE_SOURCE_STAMP): $(NEWFANGLE_SOURCE) \
                           $(FANGLE_SOURCES) ; \
        echo &gt; $(FANGLE_SOURCE_STAMP)
clean_stamp: ; rm -f $(FANGLE_SOURCE_STAMP)
clean: clean_stamp
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.5">4.3.5</a> Extracting C sources
</h3>
<div class="Standard">
We compute 
<span class="code">
FANGLE_SOURCES
</span> to hold the names of all the C source files defined in this document. We compute this only once, by means of := in assignent. The sed deletes the any &lt;&lt; and &gt;&gt; which may surround the roots names (for noroots compatibility). 
</div>
<div class="Standard">
As we use chunk names beginning with ./ to denote top level fragments that should be extracted, we filter out all fragments that do not begin with ./
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">FANGLE_PREFIX:=\.\/
FANGLE_SOURCES:=$(shell \
  fangle -r $(FANGLE_SOURCE) |\
  sed -e 's/^[&lt;][&lt;]//;s/[&gt;][&gt;]$$//;/^$(FANGLE_PREFIX)/!d' \
      -e 's/^$(FANGLE_PREFIX)/\.\//' )
@
</code>
</div>
</div>
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">.PHONY: echo_fangle_sources
echo_fangle_sources: ; @echo $(FANGLE_SOURCES)
</code>
</div>
</div>
</div>
<div class="Standard">
We define a convenient target called 
<span class="code">
fangle_sources
</span> to re-extract the source if the LaTeX file has been updated.
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">.PHONY: fangle_sources
fangle_sources: $(FANGLE_SOURCE_STAMP)
</code>
</div>
</div>
</div>
<div class="Standard">
And also a convenient target to remove extracted sources.
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">.PHONY: clean_fangle_sources
clean_fangle_sources: ; \
        rm -f -- $(FANGLE_SOURCE_STAMP) $(NEWFANGLE_SOURCES)
</code>
</div>
</div>
</div>
<div class="Standard">
This 
<span class="code">
if_extension
</span> macro takes 4 arguments: the filename (1), some extensions to match (2) and a some shell command to return if the filename matches the exentions (3), or not (4).
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if_extension=$(if $(findstring $(suffix $(1)),$(2)),$(3),$(4))
</code>
</div>
</div>
</div>
<div class="Standard">
For some source files like C files, we want to output the line number and filename of the original LaTeX document from which the source came.
</div>
<div class="Standard">
To make this easier we define the file extensions for which we want to do this.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">C_EXTENSIONS=.c .h
</code>
</div>
</div>
</div>
<div class="Standard">
We can then use the if_extensions macro to define a macro which expands out to the 
<span class="code">
-L
</span> option if fangle is being invoked in a C source file, so that C compile errors will refer to the line number in the Lyx document. 
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">TABS=8
nf_line=-L -T$(TABS)
fangle=newfangle \
  $(call if_extension,$(2),$(C_EXTENSIONS),$(nf_line)) \
    -R"$(2)" $(1)
</code>
</div>
</div>
</div>
<div class="Standard">
We can use a similar trick to define an <i>indent</i> macro which takes just the filename as an argument and can return a pipeline stage calling the indent command. Indent can be turned off with 
<span class="code">
make fangle_sources indent=
</span>
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">indent_options=-npro -kr -i8 -ts8 -sob -l80 -ss -ncs
indent=$(call if_extension,$(1),$(C_EXTENSIONS),\
              | indent $(indent_options))
</code>
</div>
</div>
</div>
<div class="Standard">
We now define the pattern for extracting a file. The files are written using noweb's <i>cpif<span class="FootMarker"> [D->] </span>
<span class="Foot">
<span class="FootMarker">[->D] </span><i>So you still need noweb installed in order to use cpif</i>
</span></i> so that the file timestamp will not be touched if the contents haven't changed. This avoids the need to rebuild the entire project because of a typographical change in the documentation, or if only a few C source files have changed.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">fangle_extract=@mkdir -p $(dir $(1)) &amp;&amp; \
  $(call fangle,$(2),$(1)) &gt; "$(1).tmp" &amp;&amp; \
  cat "$(1).tmp" $(indent) | cpif "$(1)" \
  &amp;&amp; rm -- "$(1).tmp" || \
  (echo error newfangling $(1) from $(2) ; exit 1)
</code>
</div>
</div>
</div>
<div class="Standard">
We define a target which will extract or update all sources. To do this we first defined a makefile template that can do this for any source file in the LaTeX document.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">define FANGLE_template
  $(1): $(2); \
    $$(call fangle_extract,$(1),$(2))
  FANGLE_TARGETS+=$(1)
endef
</code>
</div>
</div>
</div>
<div class="Standard">
We then enumerate the discovered 
<span class="code">
NEWTANGLE_SOURCES
</span> to generate a makefile rule for each one using the makefile template we defined above.
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(foreach source,$(FANGLE_SOURCES),\
  $(eval $(call FANGLE_template,$(source),$(NEWFANGLE_SOURCE))) \
)
</code>
</div>
</div>
</div>
<div class="Standard">
These will all be built with FANGLE_SOURCE_STAMP.
</div>
<div class="Standard">
We also remove the generated sources on a <i>make distclean</i>.
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">_distclean: clean_fangle_sources
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.6">4.3.6</a> Extracting Documentation
</h3>
<div class="Standard">
We then identify the intermediate stages of the documentation and their build and clean targets.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-4.3.6.1">4.3.6.1</a> Running pdflatex
</h4>
<div class="Standard">
We produce a pdf file from the tex file.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">FANGLE_PDF=$(TEX_SOURCE:.tex=.pdf)
</code>
</div>
</div>
</div>
<div class="Standard">
We run pdflatex twice to be sure that the contents and aux files are up to date. We certainly are required to run pdflatex twice if these files do not exist!
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$(FANGLE_PDF): $(TEX_SOURCE); pdflatex $&lt; &amp;&amp; pdflatex $&lt;
clean_pdf: ; rm -f -- $(FANGLE_PDF) \
                      $(TEX_SOURCE:.tex=.toc) \
                      $(TEX_SOURCE:.tex=.log) \
                      $(TEX_SOURCE:.tex=.aux)
</code>
</div>
</div>
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-4.3.6.2">4.3.6.2</a> The docs as a whole
</h4>
<div class="Standard">
Currently we only build pdf as a final format, but FANGLE_DOCS may later hold other output formats.
</div>
<div class="Chunk">
Makefile.inc-vars
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">FANGLE_DOCS=$(NEWFANGLE_PDF)
</code>
</div>
</div>
</div>
<div class="Standard">
We also define fangle_docs as a convenient phony target&lt;
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">.PHONY: fangle_docs
fangle_docs: $(FANGLE_DOCS)
docs: fangle_docs
</code>
</div>
</div>
</div>
<div class="Standard">
And define a convenient clean_noweb_docs which we add to the regular clean target
</div>
<div class="Chunk">
Makefile.inc-targets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">.PHONEY: clean_fangle_docs
clean_fangle_docs: clean_tex clean_pdf
clean: clean_fangle_docs

distclean_fangle_docs: clean_tex clean_newfangle_docs
distclean: clean distclean_fangle_docs
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.7">4.3.7</a> Other helpers
</h3>
<div class="Standard">
If Makefile.inc is included into Makefile, then extracted files can be updated with this command:
</div>
<pre class="LyX-Code">
make fangle_sources
</pre>
<div class="Standard">
otherwise, with:
</div>
<pre class="LyX-Code">
make -f Makefile.inc fangle_sources
</pre>
<h1 class="Part">
<a class="toc" name="toc-Part-2">Part 2.</a> Source Code
</h1>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-5">5</a> Fangle awk source code
</h1>
<div class="Standard">
We use the copyright notice from chapter <a class="Reference" href="#cha:License">?</a>.
</div>
<div class="Chunk">
./fangle,language=awk,morestring=[b]{/},morekeywords=else
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">#! /usr/bin/awk -f
# =&lt;\chunkref{gpl3-copyright}&gt;

</code>
</div>
</div>
</div>
<div class="Standard">
We also use code from Arnold Robbins public domain getopt (1993 revision) defined in chapter <a class="Reference" href="#cha:getopt">12?</a>, and naturally want to attribute this appropriately.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">
# NOTE: Arnold Robbins public domain getopt for awk is also used:
=&lt;\chunkref{getopt.awk-header}&gt;

=&lt;\chunkref{getopt.awk-getopt()}&gt;

</code>
</div>
</div>
</div>
<div class="Standard">
And include the following chunks
</div>
<div class="Chunk">
./fangle
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{helper-functions}&gt;
=&lt;\chunkref{mode-tracker}&gt;
=&lt;\chunkref{parse_chunk_args}&gt;
=&lt;\chunkref{chunk-storage-functions}&gt;
=&lt;\chunkref{output_chunk_names()}&gt;
=&lt;\chunkref{output_chunks()}&gt;
=&lt;\chunkref{write_chunk()}&gt;
=&lt;\chunkref{expand_chunk_args()}&gt;
=&lt;\chunkref{begin}&gt;
=&lt;\chunkref{recognize-chunk}&gt;
=&lt;\chunkref{end}&gt;
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.1">5.1</a> AWK tricks
</h2>
<div class="Standard">
The portable way to erase an array in awk is to split the empty string, like this:
</div>
<div class="Chunk">
awk-delete-array,params=ARRAY
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">split("", ${ARRAY});
</code>
</div>
</div>
</div>
<div class="Chunk">
dump-array,params=ARRAY
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">print "\nDump: ${ARRAY}\n--------\n" &gt; "/dev/stderr";
for (_x in ${ARRAY}) {
  print _x "=" ${ARRAY}[_x] "\n" &gt; "/dev/stderr";
}
print "========\n" &gt; "/dev/stderr";
</code>
</div>
</div>
</div>
<div class="Chunk">
,params=
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.2">5.2</a> Catching errors
</h2>
<div class="Standard">
Fatal errors are issued with the error function:
</div>
<div class="Chunk">
error(),append=helper-functions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function error(message)
{
  print "ERROR: " FILENAME ":" FNR " " message &gt; "/dev/stderr";
  exit 1;
}
</code>
</div>
</div>
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function warning(message)
{
  print "WARNING: " FILENAME ":" FNR " " message &gt; "/dev/stderr";
  warnings++;
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-6">6</a> lstlistings
</h1>
<div class="Standard">
LaTeX arguments to lstlistings macros are a comma seperated list of key-value pairs. Values containing commas are enclosed in 
<span class="code">
{
</span> braces 
<span class="code">
}
</span>, which is to be expected for LaTeX.
</div>
<div class="Standard">
A sample expressions is:
</div>
<pre class="LyX-Code">
name=thomas, params={a, b}, something, something-else
</pre>
<div class="Standard">
but we see that this is just a simpler form of this expression:
</div>
<pre class="LyX-Code">
name=freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
</pre>
<div class="Standard">
We may consider that we need a function that can parse such LaTeX expressions and assign the values to an <span class="versalitas">AWK</span> associated array, perhaps using a recursive parser into a multi-dimensional hash<span class="FootMarker"> [E->] </span>
<span class="Foot">
<span class="FootMarker">[->E] </span>as AWK doesn't have nested-hash support
</span>, resulting in:
</div>
<div class="Standard">

<table>

<tr>

<td align="left" valign="top">
key
</td>
<td align="left" valign="top">
value
</td>
</tr>
<tr>

<td align="left" valign="top">
a[name]
</td>
<td align="left" valign="top">
freddie
</td>
</tr>
<tr>

<td align="left" valign="top">
a[foo, bar]
</td>
<td align="left" valign="top">
baz
</td>
</tr>
<tr>

<td align="left" valign="top">
a[foo, quux, quirk]
</td>
<td align="left" valign="top">

</td>
</tr>
<tr>

<td align="left" valign="top">
a[foo, quux, a]
</td>
<td align="left" valign="top">
fleeg
</td>
</tr>
<tr>

<td align="left" valign="top">
a[etc]
</td>
<td align="left" valign="top">

</td>
</tr>
</table>
</div>
<div class="Standard">
Oon reflection it seems that sometimes such nesting is not desirable, as the braces are also used to delimit values that contain commas --- we may consider that
</div>
<pre class="LyX-Code">
name={williamson, freddie}
</pre>
<div class="Standard">
should assign 
<span class="code">
williamson, freddie
</span> to 
<span class="code">
name
</span>.
</div>
<div class="Standard">
In fact we are not so interested in the detail so as to be bothered by this, which turns out to be a good thing for two reasons. Firstly LaTeX has a malleable parser with no strict syntax, and secondly whether or not 
<span class="code">
williamson
</span> and 
<span class="code">
freddie
</span> should count as two items will be context dependant anyway.
</div>
<div class="Standard">
We need to parse this latex for only one reason; which is that we are extending lstlistings to add some additional arguments which will be used to express chunk parameters and other chunk options.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.1">6.1</a> Additional lstlstings parameters
</h2>
<div class="Standard">
Further on we define a 
<span class="code">
\Chunk
</span> LaTeX macro whose arguments will consist of a the chunk name, optionally followed by a comma and then a comma separated list of arguments. In fact we will just need to prefix 
<span class="code">
name=
</span> to the arguments to in order to create valid lstlistings arguments. 
</div>
<div class="Standard">
There will be other arguments supported too; 
</div>
<div class="Description">
<span class="Description-entry">params </span>As an extension to many literate-programming styles, fangle permits code chunks to take parameters and thus operate somewhat like C pre-processor macros, or like C++ templates. Chunk parameters are declared with a chunk argument called 
<span class="code">
params
</span>, which holds a semi-colon separated list of parameters, like this:
</div>
<pre class="LyX-Code">
achunk,language=C,params=name;address
</pre>
<div class="Description">
<span class="Description-entry">addto </span>a named chunk that this chunk is to be included into. This saves the effort of having to declare another listing of the named chunk merely to include this one.
</div>
<div class="Standard">
Function 
<span class="Flex">
get_chunk_args()
</span> will accept two paramters, 
<span class="code">
text
</span> being the text to parse, and 
<span class="code">
values
</span> being an array to receive the parsed values as described above. The optional parameter 
<span class="code">
path
</span> is used during recursion to build up the multi-dimensional array path.
</div>
<div class="Chunk">
./fangle
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{get_chunk_args()}&gt;
</code>
</div>
</div>
</div>
<div class="Chunk">
get_chunk_args()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function get_chunk_args(text, values,
  # optional parameters
  path, # hierarchical precursors
  # local vars
  a, name)
</code>
</div>
</div>
</div>
<div class="Standard">
The strategy is to parse the name, and then look for a value. If the value begins with a brace 
<span class="code">
{
</span>, then we recurse and consume as much of the text as necessary, returning the remaining text when we encounter a leading close-brace 
<span class="code">
}
</span>. This being the strategy --- and executed in a loop --- we realise that we must first look for the closing brace (perhaps preceded by white space) in order to terminate the recursion, and returning remaining text.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">{
  split("", next_chunk_args);
  while(length(text)) {
    if (match(text, "^ *}(.*)", a)) {
      return a[1];
    }
    =&lt;\chunkref{parse-chunk-args}&gt;
  }
  return text;
}
</code>
</div>
</div>
</div>
<div class="Standard">
We can see that the text could be inspected with this regex:
</div>
<div class="Chunk">
parse-chunk-args
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (! match(text, " *([^,=]*[^,= ]) *(([,=]) *(([^,}]*) *,* *(.*))|)$", a)) {
  return text;
}
</code>
</div>
</div>
</div>
<div class="Standard">
and that 
<span class="code">
a
</span> will have the following values:
</div>
<div class="Standard">

<table>

<tr>

<td align="center" valign="top">
a[n]
</td>
<td align="left" valign="top">
assigned text
</td>
</tr>
<tr>

<td align="center" valign="top">
1
</td>
<td align="left" valign="top">
freddie
</td>
</tr>
<tr>

<td align="center" valign="top">
2
</td>
<td align="left" valign="top">
=freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
</td>
</tr>
<tr>

<td align="center" valign="top">
3
</td>
<td align="left" valign="top">
=
</td>
</tr>
<tr>

<td align="center" valign="top">
4
</td>
<td align="left" valign="top">
freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc
</td>
</tr>
<tr>

<td align="center" valign="top">
5
</td>
<td align="left" valign="top">
freddie
</td>
</tr>
<tr>

<td align="center" valign="top">
6
</td>
<td align="left" valign="top">
, foo={bar=baz, quux={quirk, a=fleeg}}, etc
</td>
</tr>
</table>
</div>
<div class="Standard">
a[3] will be either 
<span class="code">
=
</span> or 
<span class="code">
,
</span> and signify whether the option named in 
<span class="code">
a[1]
</span> has a value or not (respectively).
</div>
<div class="Standard">
If the option does have a value, then if the expression 
<span class="code">
substr(a[4],1,1)
</span> returns a brace 
<span class="code">
{
</span> it will signify that we need to recurse:
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">name=a[1];
if (a[3] == "=") {
  if (substr(a[4],1,1) == "{") {
    text = get_chunk_args(substr(a[4],2), values, path name SUBSEP);
  } else {
    values[path name]=a[5];
    text = a[6];
  }
} else {
  values[path name]="";
  text = a[2];
}
</code>
</div>
</div>
</div>
<div class="Standard">
We can test this function like this:
</div>
<div class="Chunk">
gca-test.awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{get_chunk_args()}&gt;
BEGIN {
  SUBSEP=".";

  print get_chunk_args("name=freddie, foo={bar=baz, quux={quirk, a=fleeg}}, etc", a);
  for (b in a) {
    print "a[" b "] =&gt; " a[b];
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">
which should give this output:
</div>
<div class="Chunk">
gca-test.awk-results
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">a[foo.quux.quirk] =&gt; 
a[foo.quux.a] =&gt; fleeg
a[foo.bar] =&gt; baz
a[etc] =&gt; 
a[name] =&gt; freddie
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.2">6.2</a> Parsing chunk arguments
</h2>
<div class="Standard">
<a class="Label" name="cha:Chunk Arguments"> </a>
</div>
<div class="Standard">
Arguments to paramterized chunks are expressed in round brackets as a comma separated list of optional arguments. For example, a chunk that is defined with:
</div>
<pre class="LyX-Code">
\Chunk{achunk, params=name ; address}
</pre>
<div class="Standard">
could be invoked as:
</div>
<pre class="LyX-Code">
\chunkref{achunk}(John Jones, jones@example.com)
</pre>
<div class="Standard">
An argument list may be as simple as in 
<span class="code">
\chunkref{pull}(thing, otherthing)
</span> or as complex as:
</div>
<pre class="LyX-Code">
\chunkref{pull}(things[x, y], get_other_things(a, "(all)")) 
</pre>
<div class="Standard">
--- which for all it's commas and quotes and parenthesis represents only two parameters: 
<span class="code">
things[x, y]
</span> and 
<span class="code">
get_other_things(a, "(all)")
</span>.
</div>
<div class="Standard">
If we simply split parameter list on commas, then the comma in 
<span class="code">
things[x,y]
</span> would split into two seperate arguments: 
<span class="code">
things[x
</span> and 
<span class="code">
y]
</span>--- neither of which make sense on their own.
</div>
<div class="Standard">
One way to prevent this would be by refusing to split text between matching delimiters, such as 
<span class="code">
[
</span>, 
<span class="code">
]
</span>, 
<span class="code">
(
</span>, 
<span class="code">
)
</span>, 
<span class="code">
{
</span>, 
<span class="code">
}
</span> and most likely also 
<span class="code">
"
</span>, 
<span class="code">
"
</span> and 
<span class="code">
'
</span>, 
<span class="code">
'
</span>. Of course this also makes it impossible to pass such mis-matched code fragments as parameters, but I think that it would be hard for readers to cope with authors who would pass such code unbalanced fragments as chunk parameters<span class="FootMarker"> [F->] </span>
<span class="Foot">
<span class="FootMarker">[->F] </span>I know that I couldn't cope with users doing such things, and although the GPL3 license prevents me from actually forbidding anyone from trying, if they want it to work they'll have to write the code themselves and not expect any support from me.
</span>.
</div>
<div class="Standard">
Unfortunately, the full set of matching delimiters may vary from language to language. In certain C++ template contexts, 
<span class="code">
&lt;
</span> and 
<span class="code">
&gt;
</span> would count as delimiters, and yet in other contexts they would not.
</div>
<div class="Standard">
This puts me in the unfortunate position of having to parse-somewhat all programming languages without knowing what they are!
</div>
<div class="Standard">
However, if this universal mode-tracking is possible, then parsing the arguments would be trivial. Such a mode tracker is described in chapter <a class="Reference" href="#cha:modes">?</a> and used here with simplicity.
</div>
<div class="Chunk">
parse_chunk_args
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function parse_chunk_args(language, text, values, mode,
  # local vars
  c, context, rest)
{
  =&lt;\chunkref{new-mode-tracker}(context, language, mode)&gt;
  rest = mode_tracker(context, text, values);
  # extract values
  for(c=1; c &lt;= context[0, "values"]; c++) {
    values[c] = context[0, "values", c];
  }
  return rest;
}
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.3">6.3</a> Expanding parameters in the text
</h2>
<div class="Standard">
Within the body of the chunk, the parameters are referred to with: 
<span class="code">
${name}
</span> and 
<span class="code">
${address}
</span>. There is a strong case that a LaTeX style notation should be used, like \param{name} which would be expressed in the listing as =&lt;\param{name}&gt; and be rendered as 
<div class="float">

<div class="listing">
<code class="listing">=&lt;\param{name}&gt;
</code>
</div>
</div>. Such notation would make me go blind, but I do intend to adopt it<span class="FootMarker"> [G->] </span>
<span class="Foot">
<span class="FootMarker">[->G] </span>Probably when LyX's listings inset can recognize and render it, so that I no longer have to type =&lt;...&gt;
</span>.
</div>
<div class="Standard">
We therefore need a function 
<span class="code">
expand_chunk_args
</span> which will take a block of text, a list of permitted parameters, and the arguments which must substitute for the parameters. 
</div>
<div class="Standard">
<a class="Label" name="Here-we-split"> </a>Here we split the text on 
<span class="code">
${
</span> which means that all parts except the first will begin with a parameter name which will be terminated by 
<span class="code">
}
</span>. The split function will consume the literal 
<span class="code">
${
</span> in each case.
</div>
<div class="Chunk">
expand_chunk_args()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function expand_chunk_args(text, params, args,  
  p, text_array, next_text, v, t, l)
{
  if (split(text, text_array, "\\${")) {
    =&lt;\chunkref{substitute-chunk-args}&gt;
  }

  return text;
}
</code>
</div>
</div>
</div>
<div class="Standard">
First, we produce an associative array of substitution values indexed by parameter names. This will serve as a cache, allowing us to look up the replacement values as we extract each name.
</div>
<div class="Chunk">
substitute-chunk-args
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">for(p in params) {
  v[params[p]]=args[p];
}
</code>
</div>
</div>
</div>
<div class="Standard">
We accumulate substituted text in the variable 
<span class="code">
text
</span>. As the first part of the split function is the part before the delimiter --- which is 
<span class="code">
${
</span> in our case --- this part will never contain a parameter reference, so we assign this directly to the result kept in 
<span class="code">
$text
</span>.
<div class="float">

<div class="listing">
<code class="listing">text=text_array[1];
</code>
</div>
</div>
</div>
<div class="Standard">
We then iterate over the remaining values in the array<span class="FootMarker"> [H->] </span>
<span class="Foot">
<span class="FootMarker">[->H] </span>I don't know why I think that it will enumerate the array in order, but it seems to work
</span>, and substitute each reference for it's argument.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">for(t=2; t in text_array; t++) {
  =&lt;\chunkref{substitute-chunk-arg}&gt;
}
</code>
</div>
</div>
</div>
<div class="Standard">
After the split on 
<span class="code">
${
</span> a valid parameter reference will consist of valid parameter name terminated by a close-brace 
<span class="code">
}
</span>. A valid character name begins with the underscore or a letter, and may contain letters, digits or underscores.
</div>
<div class="Standard">
A valid looking reference that is not actually the name of a parameter will be and not substituted. This is good because there is nothing to substitute anyway, and it avoids clashes when writing code for languages where ${...} is a valid construct --- such constructs will not be interfered with unless the parameter name also matches.
</div>
<div class="Chunk">
substitute-chunk-arg
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (match(text_array[t], "^([a-zA-Z_][a-zA-Z0-9_]*)}", l) &amp;&amp;
    l[1] in v) 
{
  text = text v[l[1]] substr(text_array[t], length(l[1])+2);
} else {
  text = text "${" text_array[t];
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-7">7</a> Language Modes
</h1>
<div class="Standard">
<a class="Label" name="cha:modes"> </a>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.1">7.1</a> Modes
</h2>
<div class="Standard">
lstlistings and fangle both recognize source languages, and perform some basic parsing. lstlistings can detect strings and comments within a language definition and perform suitable rendering, such as italics for comments, and visible-spaces within strings.
</div>
<div class="Standard">
Fangle similarly can recognize strings, and comments, etc, within a language, so that any chunks included with 
<span class="code">
\chunkref
</span> can be suitably escape or quoted.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.1">7.1.1</a> Modes to keep code together
</h3>
<div class="Standard">
As an example, in the C language there are a few parse modes, affecting the interpretation of characters.
</div>
<div class="Standard">
One parse mode is the strings mode. The string mode is commenced by an un-escaped quotation mark 
<span class="code">
"
</span> and terminated by the same. Within the string mode, only one additional mode can be commenced, it is the backslash mode 
<span class="code">
\
</span>, which is always terminated by the folloing character.
</div>
<div class="Standard">
Other modes are 
<span class="code">
[
</span> which is terminated by a 
<span class="code">
]
</span> (unless it occurs in a string).
</div>
<div class="Standard">
Consider this line of C code:
</div>
<div class="Standard">
<span class="formula"><tt>things<span class="unknown">\underbrace</span>[<tt>x, <span class="unknown">\ </span>y</tt>]<sub>1.<span class="unknown">\ </span>[<span class="unknown">\ </span>mode</sub>, <span class="unknown">\ </span>get_other_things<span class="unknown">\underbrace</span>(<tt>a, <span class="unknown">\overbrace</span>"<tt>(all)</tt>"</tt>)<sub>2.<span class="unknown">\ </span>(<span class="unknown">\ </span>mode</sub><sup>3.<span class="unknown">\ </span>"<span class="unknown">\ </span>mode</sup></tt></span>
</div>
<div class="Standard">
Mode nesting prevents the close parenthesis in quote mode (part 3) from terminating the parenthesis mode (part 2).
</div>
<div class="Standard">
Each language has a set of modes, the default mode being the null mode. Each mode can lead to other modes.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.2">7.1.2</a> Modes to included chunks
</h3>
<div class="Standard">
For instance, consider this chunk with 
<span class="code">
language=perl
</span>:
</div>
<div class="Chunk">
example-perl,language=perl
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">s/"$/'/;
</code>
</div>
</div>
</div>
<div class="Standard">
If it were included in a chunk with 
<span class="code">
language=sh
</span>, like this:
</div>
<div class="Chunk">
example-sh,language=sh
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">perl -pe "=&lt;\chunkref{example-perl}&gt;"
</code>
</div>
</div>
</div>
<div class="Standard">
fangle would need to generate output like this if it were to work: 
</div>
<pre class="LyX-Code">
perl -pe "s/\"\$/'/;"
</pre>
<div class="Standard">
See that the double quote 
<span class="code">
"
</span>, and 
<span class="code">
$
</span> in the regex have been quoted with a back-slash to protect them from shell interpretation.
</div>
<div class="Standard">
If that were then included in a chunk with 
<span class="code">
language=make
</span>, like this:
</div>
<div class="Chunk">
example-makefile,language=make
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">target: pre-req
		=&lt;\chunkref{example-sh}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We would need the output to look like this --- note the $$:
</div>
<pre class="LyX-Code">
target: pre-req
</pre>
<pre class="LyX-Code">
        perl -pe "s/\"\$$/'/;"
</pre>
<div class="Standard">
In order to make this work, we need to define a mode-tracker supporting each language, that can detect the various quoting modes, and provide a transformation that must be applied to any included text so that included text will be interpreted correctly after any interpolation that it may be subject to at run-time.
</div>
<div class="Standard">
For example, the sed transformation for text to be inserted into sh double-quoted strings would be something like:
</div>
<pre class="LyX-Code">
s/\\/\\\\/g;s/$/\\$/g;s/"/\\"/g;
</pre>
<div class="Standard">
which protects 
<span class="code">
\ $ "
</span>.
</div>
<div class="Standard">
The mode tracker must also track nested mode-changes, as in this 
<span class="code">
sh
</span> example.
</div>
<pre class="LyX-Code">
echo "hello 'id ...'"
</pre>
<pre class="LyX-Code">
?
</pre>
<div class="Standard">
Any characters inserted at the point marked ? would need to be escaped, including 
<span class="code">
' | *
</span> among others. First it would need escaping for the back-ticks ', and then for the double-quotes ".
</div>
<div class="Standard">
Escaping need not occur if the format and mode of the included chunk matches that of the including chunk.
</div>
<div class="Standard">
As each chunk is output a new mode tracker for that language is initialized in it's normal state. As text is output for that chunk the output mode is tracked. When a new chunk is included, a transformation appropriate to that mode is selected and pushed onto a stack of transformations. Any text to be output is first passed through this stack of transformations.
</div>
<div class="Standard">
It remains to consider if the chunk-include function should return it's generated text so that the caller can apply any transformations (and formatting), or if it should apply the stack of transformations itself.
</div>
<div class="Standard">
Note that the transformed text should have the property of not being able to change the mode in the current chunk.
</div>
<div class="Standard">

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.2">7.2</a> Language Mode Definitions
</h2>
<div class="Standard">
All modes are stored in a single multi-dimensional hash. The first index is the language, and the second index is the mode-identifier. The third indexes are terminators, and optionally, submodes, and delimiters.
</div>
<div class="Standard">
A useful set of mode definitions for a nameless general C-type language is shown here. (Don't be confused by the double backslash escaping needed in awk. One set of escaping is for the string, and the second set of escaping is for the regex). 
</div>
<div class="Standard">
Submodes are entered by the characters 
<span class="code">
\
</span> 
<span class="code">
"
</span> 
<span class="code">
'
</span> 
<span class="code">
{
</span> 
<span class="code">
(
</span> 
<span class="code">
[
</span> 
<span class="code">
/*
</span>
</div>
<div class="Chunk">
common-mode-definitions,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, "",  "submodes" ]="\\\\|\"|'|{|\\(|\\[";
</code>
</div>
</div>
</div>
<div class="Standard">
In the default mode, a comma surrounded by un-important white space is a delimiter of language items.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, "",  "delimiters"]=" *, *";
</code>
</div>
</div>
</div>
<div class="Standard">
and should pass this test:
</div>
<div class="Standard">

</div>
<div class="Chunk">
test:mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">parse_chunk_args("c-like", "1,2,3", a, "");
if (a[1] != "1") e++;
if (a[2] != "2") e++;
if (a[3] != "3") e++;
if (length(a) != 3) e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;

parse_chunk_args("c-like", "joe, red", a, "");
if (a[1] != "joe") e++;
if (a[2] != "red") e++;
if (length(a) != 2) e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;

parse_chunk_args("c-like", "${colour}", a, "");
if (a[1] != "${colour}") e++;
if (length(a) != 1) e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
Nested modes are identified by a backslash, a double or single quote, various bracket styles or a /* comment.
</div>
<div class="Standard">
For each of these sub-modes modes we must also identify at a mode terminator, and any sub-modes or delimiters that may be entered<span class="FootMarker"> [I->] </span>
<span class="Foot">
<span class="FootMarker">[->I] </span>Because we are using the sub-mode characters as the mode identifier it means we can't currently have a mode character dependant on it's context; i.e. 
<span class="code">
{
</span> can't behave differently when it is inside 
<span class="code">
[
</span>.
</span>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.1">7.2.1</a> Backslash
</h3>
<div class="Standard">
The backslash mode has no submodes or delimiters, and is terminated by any character. Note that we are not so much interested in evaluating or interpolating content as we are in delineating content. It is no matter that a double backslash (
<span class="code">
\\
</span>) may represent a single backslash while a backslash-newline may represent white space, but it does matter that the newline in a backslash newline should not be able to terminate a C pre-processor statement; and so the newline will be consumed by the backslash however it is to be interpreted.
</div>
<div class="Chunk">
common-mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, "\\", "terminators"]=".";
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.2">7.2.2</a> Strings
</h3>
<div class="Standard">
Common languages support two kinds of strings quoting, double quotes and single quotes.
</div>
<div class="Chunk">
mode:common-string,params=language;quote
</div>
<div class="Standard">
In a string we have one special mode, which is the backslash. This may escape an embedded quote and prevent us thinking that it should terminate the string. 
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, ${quote}, "submodes" ]="\\\\";
</code>
</div>
</div>
</div>
<div class="Standard">
Otherwise, the string will be terminated by the same character that commenced it.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, ${quote}, "terminators"]=${quote};
</code>
</div>
</div>
</div>
<div class="Standard">
In C type languages, certain escape sequences exist in strings. We need to define mechanism to enclode any chunks included in this mode using those escape sequences. These are expressed in two parts, s meaning search, and r meaning replace.
</div>
<div class="Standard">
The first substitution is to replace a backslash with a double backslash. We do this first as other substitutions may introduce a backslash which we would not then want to escape again here.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]="\\";
escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\\\";
</code>
</div>
</div>
</div>
<div class="Standard">
If the quote character occurs in the text, it should be preceded by a backslash, otherwise it would terminate the string unexpectedly.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]=${quote};
escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\" ${quote};
</code>
</div>
</div>
</div>
<div class="Standard">
Any newlines in the string, must be replaced by 
<span class="code">
\n
</span>
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">escapes[${language}, ${quote}, ++escapes[${language}, ${quote}], "s"]="\n";
escapes[${language}, ${quote},   escapes[${language}, ${quote}], "r"]="\\n";
</code>
</div>
</div>
</div>
<div class="Standard">
For the common modes, we define this string handling for double and single quotes.
</div>
<div class="Chunk">
common-mode-definitions,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:common-string}(${language}, "\textbackslash{}"")&gt;
=&lt;\chunkref{mode:common-string}(${language}, "'")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
Working strings should pass this test:
</div>
<div class="Chunk">
test:mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">parse_chunk_args("c-like", "say \"I said, \\\"Hello, how are you\\\".\", for me", a, "");
if (a[1] != "say \"I said, \\\"Hello, how are you\\\".\"") e++;
if (a[2] != "for me") e++;
if (length(a) != 2) e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.3">7.2.3</a> Parentheses, Braces and Brackets
</h3>
<div class="Standard">
Where quotes are closed by the same character, parentheses, brackets and braces are closed by an alternate character.
</div>
<div class="Chunk">
mode:common-brackets,params=language;open;close
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, ${open},  "submodes" ]="\\\\|\"|{|\\(|\\[|'|/\\*";
modes[${language}, ${open},  "delimiters"]=" *, *";
modes[${language}, ${open},  "terminators"]=${close};
</code>
</div>
</div>
</div>
<div class="Standard">
Note that the open is NOT a regex but the close token IS. 
</div>
<div class="Chunk">
common-mode-definitions,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:common-brackets}(${language}, "{", "}")&gt;
=&lt;\chunkref{mode:common-brackets}(${language}, "[", "\textbackslash{}\textbackslash{}]")&gt;
=&lt;\chunkref{mode:common-brackets}(${language}, "(", "\textbackslash{}\textbackslash{})")&gt;
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.4">7.2.4</a> Customizing Standard Modes
</h3>
<div class="Chunk">
mode:add-submode,params=language;mode;submode
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">modes[${language}, ${mode}, "submodes"] = modes[${language}, ${mode}, "submodes"] "|" ${submode};
</code>
</div>
</div>
</div>
<div class="Chunk">
mode:add-escapes,params=language;mode;search;replace
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">escapes[${language}, ${mode}, ++escapes[${language}, ${mode}], "s"]=${search};
escapes[${language}, ${mode},   escapes[${language}, ${mode}], "r"]=${replace};
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.5">7.2.5</a> Comments
</h3>
<div class="Standard">
We can define 
<span class="code">
/* comment */
</span> style comments and 
<span class="code">
//comment
</span> style comments to be added to any language:
</div>
<div class="Chunk">
mode:multi-line-comments,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:add-submode}(${language}, "", "/\textbackslash{}\textbackslash{}*")&gt;
modes[${language}, "/*", "terminators"]="\\*/";
</code>
</div>
</div>
</div>
<div class="Chunk">
mode:single-line-slash-comments,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:add-submode}(${language}, "", "//")&gt;
modes[${language}, "//", "terminators"]="\n";
=&lt;\chunkref{mode:add-escapes}(${language}, "//", "\textbackslash{}n", "\textbackslash{}n//")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We can also define 
<span class="code">
# comment
</span> style comments (as used in awk and shell scripts) in a similar manner.
</div>
<div class="Chunk">
mode:add-hash-comments,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:add-submode}(${language}, "", "\#")&gt;
modes[${language}, "#", "terminators"]="\n";
=&lt;\chunkref{mode:add-escapes}(${language}, "\#", "\textbackslash{}n", "\textbackslash{}n\#")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
In C, the 
<span class="code">
#
</span> denotes pre-processor directives which can be multi-line 
</div>
<div class="Chunk">
mode:add-hash-defines,params=language
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{mode:add-submode}(${language}, "", "\#")&gt;
modes[${language}, "#", "submodes" ]="\\\\";
modes[${language}, "#", "terminators"]="\n";
=&lt;\chunkref{mode:add-escapes}(${language}, "\#", "\textbackslash{}n", "\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}n")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We can add these definitions to various languages
</div>
<div class="Chunk">
mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{common-mode-definitions}("c-like")&gt;

=&lt;\chunkref{common-mode-definitions}("c")&gt;
=&lt;\chunkref{mode:multi-line-comments}("c")&gt;
=&lt;\chunkref{mode:single-line-slash-comments}("c")&gt;
=&lt;\chunkref{mode:add-hash-defines}("c")&gt;

=&lt;\chunkref{common-mode-definitions}("awk")&gt;
=&lt;\chunkref{mode:add-hash-comments}("awk")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
The awk definitions should allow a comment block like this:
</div>
<div class="Chunk">
test:comment-quote,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># Comment: =&lt;\chunkref{test:comment-text}&gt;
</code>
</div>
</div>
</div>
<div class="Chunk">
test:comment-text,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">Now is the time for
the quick brown fox to bring lemonade
to the party
</code>
</div>
</div>
</div>
<div class="Standard">
to come out like this:
</div>
<div class="Chunk">
test:comment-quote:result
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># Comment: Now is the time for
#the quick brown fox to bring lemonade
#to the party
</code>
</div>
</div>
</div>
<div class="Standard">
The C definition for such a block should have it come out like this:
</div>
<div class="Chunk">
test:comment-quote:C-result
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># Comment: Now is the time for\
the quick brown fox to bring lemonade\
to the party
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.3">7.3</a> Some tests
</h2>
<div class="Standard">
Also, the parser must return any spare text at the end that has not been processed due to a mode terminator being found.
</div>
<div class="Chunk">
test:mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">rest = parse_chunk_args("c-like", "1, 2, 3) spare", a, "(");
if (a[1] != 1) e++;
if (a[2] != 2) e++;
if (a[3] != 3) e++;
if (length(a) != 3) e++;
if (rest != " spare") e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We must also be able to parse the example given earlier.
</div>
<div class="Chunk">
test:mode-definitions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">parse_chunk_args("c-like", "things[x, y], get_other_things(a, \"(all)\"), 99", a, "(");
if (a[1] != "things[x, y]") e++;
if (a[2] != "get_other_things(a, \"(all)\")") e++;
if (a[3] != "99") e++;
if (length(a) != 3) e++;
=&lt;\chunkref{pca-test.awk:summary}&gt;
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.4">7.4</a> A non-recursive mode tracker
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.1">7.4.1</a> Constructor
</h3>
<div class="Standard">
The mode tracker holds its state in a stack based on a hash. This function, when passed an empty hash will intialize it.
</div>
<div class="Chunk">
new_mode_tracker()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function new_mode_tracker(context, language, mode) {
  context[""] = 0;
  context[0, "language"] = language;
  context[0, "mode"] = mode;
}
</code>
</div>
</div>
</div>
<div class="Standard">
Because awk functions cannot return an array, we must create the array first and pass it in, so we have a fangle macro to do this:
</div>
<div class="Chunk">
new-mode-tracker,language=awk,params=context;language;mode
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{awk-delete-array}(${context})&gt;
new_mode_tracker(${context}, ${language}, ${mode});
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.2">7.4.2</a> Management
</h3>
<div class="Standard">
And for tracking modes, we dispatch to a mode-tracker action based on the current language
</div>
<div class="Chunk">
mode_tracker,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function push_mode_tracker(context, language, mode,
  # local vars
  top)
{
  if (! ("" in context)) {
    =&lt;\chunkref{new-mode-tracker}(context, language, mode)&gt;
  } else {
    top = context[""];
    if (context[top, "language"] == language &amp;&amp; mode=="") mode = context[top, "mode"];
    top++;
    context[top, "language"] = language;
    context[top, "mode"] = mode;
    context[""] = top;
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function finalize_mode_tracker(context)
{
  if ( ("" in context) &amp;&amp; context[""] != 0) return 0;
  return 1;
}
</code>
</div>
</div>
</div>
<div class="Standard">
This implies that any chunk must be syntactically whole; for instance, this is fine:
</div>
<div class="Chunk">
test:whole-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (1) {
  =&lt;\chunkref{test:say-hello}&gt;
}
</code>
</div>
</div>
</div>
<div class="Chunk">
test:say-hello
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">print "hello";
</code>
</div>
</div>
</div>
<div class="Standard">
But this is not fine; the chunk 
<span class="Flex">
test:hidden-else
</span> is not properly cromulent.
</div>
<div class="Chunk">
test:partial-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (1) {
  =&lt;\chunkref{test:hidden-else}&gt;
}
</code>
</div>
</div>
</div>
<div class="Chunk">
test:hidden-else
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  print "I'm fine";
} else {
  print "I'm not";
</code>
</div>
</div>
</div>
<div class="Standard">
These tests will check for correct behaviour:
</div>
<div class="Chunk">
test:cromulence
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">echo Cromulence test
passtest $FANGLE -Rtest:whole-chunk $TEX_SRC &amp;&gt;/dev/null || ( echo "Whole chunk failed" &amp;&amp; exit 1 )
failtest $FANGLE -Rtest:partial-chunk $TEX_SRC &amp;&gt;/dev/null || ( echo "Partial chunk failed" &amp;&amp; exit 1 )
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.3">7.4.3</a> Tracker
</h3>
<div class="Standard">
We must avoid recursion as a language construct because we intend to employ mode-tracking to track language mode of emitted code, and the code is emitted from a function which is itself recursive, so instead we implement psuedo-recursion using our own stack based on a hash.
</div>
<div class="Chunk">
mode_tracker()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function mode_tracker(context, text, values, 
  # optional parameters
  # local vars
  mode, submodes, language,
  cindex, c, a, part, item, name, result, new_values, new_mode, 
  delimiters, terminators)
{
</code>
</div>
</div>
</div>
<div class="Standard">
We could be re-commencing with a valid context, so we need to setup the state according to the last context.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  cindex = context[""] + 0;
  mode = context[cindex, "mode"];
  language = context[cindex, "language" ];
</code>
</div>
</div>
</div>
<div class="Standard">
First we construct a single large regex combining the possible sub-modes for the current mode along with the terminators for the current mode.
</div>
<div class="Chunk">
parse_chunk_args-reset-modes
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  submodes=modes[language, mode, "submodes"];

  if ((language, mode, "delimiters") in modes) {
    delimiters = modes[language, mode, "delimiters"];
    if (length(submodes)&gt;0) submodes = submodes "|";
    submodes=submodes delimiters;
  } else delimiters="";
  if ((language, mode, "terminators") in modes) {
    terminators = modes[language, mode, "terminators"];
    if (length(submodes)&gt;0) submodes = submodes "|";
    submodes=submodes terminators;
  } else terminators="";
</code>
</div>
</div>
</div>
<div class="Standard">
If we don't find anything to match on --- probably because the language is not supported --- then we return the entire text without matching anything.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  if (! length(submodes)) return text; 
</code>
</div>
</div>
</div>
<div class="Chunk">
mode_tracker()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{parse_chunk_args-reset-modes}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We then iterate the text (until there is none left) looking for sub-modes or terminators in the regex.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  while((cindex &gt;= 0) &amp;&amp; length(text)) {
    if (match(text, "(" submodes ")", a)) {
</code>
</div>
</div>
</div>
<div class="Standard">
A bug that creeps in regularly during development is bad regexes of zero length which result in an infinite loop (as no text is consumed), so I catch that right away with this test.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">      if (RLENGTH&lt;1) {
        error(sprintf("Internal error, matched zero length submode, should be impossible - likely regex computation error\n" \
		"Language=%s\nmode=%s\nmatch=%s\n", language, mode, submodes));
      }
</code>
</div>
</div>
</div>
<div class="Standard">

<span class="code">
part
</span> is defined as the text up to the sub-mode or terminator, and this is appended to 
<span class="code">
item
</span> --- which is the current text being gathered. If a mode has a delimiter, then item is reset each time a delimiter is found.
</div>
<div class="Standard">
<span class="formula"><tt><span class="unknown">\overbrace</span>"<span class="unknown">\overbrace</span>hello<sup>item</sup>, <span class="unknown">\ </span><span class="unknown">\overbrace</span>there<sup>item</sup>"<sup>item</sup>, <span class="unknown">\ </span><span class="unknown">\overbrace</span>he<span class="unknown">\ </span>said.<sup>item</sup></tt></span>
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">      part = substr(text, 1, RSTART -1);
      item = item part;
</code>
</div>
</div>
</div>
<div class="Standard">
We must now determine what was matched. If it was a terminator, then we must restore the previous mode.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">      if (match(a[1], "^" terminators "$")) {
#printf("%2d EXIT  MODE [%s] by [%s] [%s]\n", cindex, mode, a[1], text) &gt; "/dev/stderr"
        context[cindex, "values", ++context[cindex, "values"]] = item;
        delete context[cindex];
        context[""] = --cindex;
        if (cindex&gt;=0) {
          mode = context[cindex, "mode"];
          language = context[cindex, "language"];
          =&lt;\chunkref{parse_chunk_args-reset-modes}&gt;
        }
        item = item a[1];
        text = substr(text, 1 + length(part) + length(a[1]));
      }
</code>
</div>
</div>
</div>
<div class="Standard">
If a delimiter was matched, then we must store the current item in the parsed values array, and reset the item.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">      else if (match(a[1], "^" delimiters "$")) {
        if (cindex==0) {
          context[cindex, "values", ++context[cindex, "values"]] = item;
          item = "";
        } else {
          item = item a[1];
        }
        text = substr(text, 1 + length(part) + length(a[1]));
      }
</code>
</div>
</div>
</div>
<div class="Standard">
otherwise, if a new submode is detected (all submodes have terminators), we must create a nested parse context until we find the terminator for this mode.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"> else if ((language, a[1], "terminators") in modes) {
        #check if new_mode is defined
        item = item a[1];
#printf("%2d ENTER MODE [%s] in [%s]\n", cindex, a[1], text) &gt; "/dev/stderr"
        text = substr(text, 1 + length(part) + length(a[1]));
        context[""] = ++cindex;
        context[cindex, "mode"] = a[1];
        context[cindex, "language"] = language;
        mode = a[1];
        =&lt;\chunkref{parse_chunk_args-reset-modes}&gt;
      } else {
        error(sprintf("Submode '%s' set unknown mode in text: %s\nLanguage %s Mode %s\n", a[1], text, language, mode));
        text = substr(text, 1 + length(part) + length(a[1]));
      }
    }
</code>
</div>
</div>
</div>
<div class="Standard">
In the final case, we parsed to the end of the string. If the string was entire, then we should have no nested mode context, but if the string was just a fragment we may have a mode context which must be preserved for the next fragment. Todo: Consideration ought to be given if sub-mode strings are split over two fragments.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">else {
      context[cindex, "values", ++context[cindex, "values"]] = item text;
      text = "";
      item = "";
    }
  }

  context["item"] = item;

  if (length(item)) context[cindex, "values", ++context[cindex, "values"]] = item;
  return text;
}
</code>
</div>
</div>
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-7.4.3.1">7.4.3.1</a> One happy chunk
</h4>
<div class="Standard">
All the mode tracker chunks are referred to here:
</div>
<div class="Chunk">
mode-tracker
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{new_mode_tracker()}&gt;
=&lt;\chunkref{mode_tracker()}&gt;
</code>
</div>
</div>
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-7.4.3.2">7.4.3.2</a> Tests
</h4>
<div class="Standard">
We can test this function like this:
</div>
<div class="Chunk">
pca-test.awk,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{error()}&gt;
=&lt;\chunkref{mode-tracker}&gt;
=&lt;\chunkref{parse_chunk_args()}&gt;
BEGIN {
  SUBSEP=".";
  =&lt;\chunkref{mode-definitions}&gt;

  =&lt;\chunkref{test:mode-definitions}&gt;
}
</code>
</div>
</div>
</div>
<div class="Chunk">
pca-test.awk:summary,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (e) {
  printf "Failed " e
  for (b in a) {
    print "a[" b "] =&gt; " a[b];
  }
} else {
  print "Passed"
}
split("", a);
e=0;
</code>
</div>
</div>
</div>
<div class="Standard">
which should give this output:
</div>
<div class="Chunk">
pca-test.awk-results,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">a[foo.quux.quirk] =&gt; 
a[foo.quux.a] =&gt; fleeg
a[foo.bar] =&gt; baz
a[etc] =&gt; 
a[name] =&gt; freddie
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.5">7.5</a> Escaping and Quoting
</h2>
<div class="Standard">
Each nested mode can optionally define a set of transforms to be applied to any text that is included from another language.
</div>
<div class="Standard">
This code can perform transforms
</div>
<div class="Chunk">
mode_tracker,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function transform_escape(s, r, text,
    # optional
    max, 
	# local vars
	c)
{
  for(c=1; c &lt;= max &amp;&amp; (c in s); c++) {
    gsub(s[c], r[c], text);
  }
  return text;
}
</code>
</div>
</div>
</div>
<div class="Standard">
This function must append from index 
<span class="code">
c
</span> onwards, and escape transforms from the supplied context, and return c + number of new transforms.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function mode_escaper(context, s, r, src,
  c, cp, cpl)
{
	for(c = context[""]; c &gt;= 0; c--) {
		if ( (context[c, "language"], context[c, "mode"]) in escapes) {
			cpl = escapes[context[c, "language"], context[c, "mode"]];
			for (cp = 1; cp &lt;= cpl; cp ++) {
				++src;
				s[src] = escapes[context[c, "language"], context[c, "mode"], c, "s"];
				r[src] = escapes[context[c, "language"], context[c, "mode"], c, "r"];
			}
		}
	}
	return src;
}
</code>
</div>
</div>
</div>
<div class="Chunk">
test:escapes,language=sh
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">echo escapes test
passtest $FANGLE -Rtest:comment-quote $TEX_SRC &amp;&gt;/dev/null || ( echo "Comment-quote failed" &amp;&amp; exit 1 )
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-8">8</a> Recognizing Chunks
</h1>
<div class="Standard">
Fangle recognizes noweb chunks, but as we also want better LaTeX integration we will recognize any of these:
</div>
<ul>

<li>
notangle chunks matching the pattern 
<span class="code">
^&lt;&lt;.*?&gt;&gt;=
</span>
</li>
<li>
a chunks beginning with 
<span class="code">
\begin{lstlistings}
</span>, possibly with \Chunk{...} on the previous line
</li>
<li>
an older form I have used, beginning with 
<span class="code">
\begin{Chunk}[options]
</span> --- also more suitable for plain LaTeX users<span class="FootMarker"> [J->] </span>
<span class="Foot">
<span class="FootMarker">[->J] </span>Is there such a thing as plain LaTeX?
</span>.
</li>
</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-8.1">8.1</a> Chunk start
</h2>
<div class="Standard">
The variable 
<span class="code">
chunking
</span> is used to signify that we are processing a code chunk and not document. In such a state, input lines will be assigned to the current chunk; otherwise they are ignored.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.1">8.1.1</a> lstlistings
</h3>
<div class="Standard">
Our current scheme is to recognize the new lstlisting chunks, but these may be preceded by a 
<span class="code">
\Chunk
</span> command which in LyX is a more convenient way to pass the chunk name to the 
<span class="code">
\begin{lstlistings}
</span> command, and a more visible way to specify other 
<span class="code">
lstset
</span> settings.
</div>
<div class="Standard">
The arguments to the 
<span class="code">
\Chunk
</span> command are a name, and then a comma-seperated list of key-value pairs after the manner of 
<span class="code">
\lstset
</span>. (In fact within the LaTeX 
<span class="code">
\Chunk
</span> macro (section <a class="Reference" href="#sub:The-chunk-command">13.2.1?</a>) the text 
<span class="code">
name=
</span> is prefixed to the argument which is then literally passed to 
<span class="code">
\lstset
</span>).
</div>
<div class="Chunk">
recognize-chunk,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">/^\\Chunk{/ {
  if (match($0, "^\\\\Chunk{ *([^ ,}]*),?(.*)}", line)) {
    next_chunk_name = line[1];
    get_chunk_args(line[2], next_chunk_args);
  }
  next;
}
</code>
</div>
</div>
</div>
<div class="Standard">
We also make a basic attempt to parse the name out of the 
<span class="code">
\lstlistings[name= chunk-name]
</span> text, otherwise we fall back to the name found in the previous chunk command. This attempt is very basic and doesn't support commas or spaces or square brackets as part of the chunkname. We also recognize 
<span class="code">
\begin{Chunk}
</span> which is convenient for some users<span class="FootMarker"> [K->] </span>
<span class="Foot">
<span class="FootMarker">[->K] </span>but not yet supported in the LaTeX macros
</span>.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">/^\\begin{lstlisting}|^\\begin{Chunk}/ {
  if (match($0, "}.*[[,] *name= *{? *([^], }]*)", line)) {
    new_chunk(line[1]);
  } else {
    new_chunk(next_chunk_name, next_chunk_args);
  }
  chunking=1;
  next;
}
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.2">8.1.2</a> Noweb
</h3>
<div class="Standard">
We recognize notangle style chunks too:
</div>
<div class="Chunk">
recognize-chunk,language=awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">/^[&lt;]&lt;.*[&gt;]&gt;=/ {
  if (match($0, "^[&lt;]&lt;(.*)[&gt;]&gt;= *$", line)) {
    chunking=1;
    notangle_mode=1;
    new_chunk(line[1]);
    next;
  }
}
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.2">8.2</a> Chunk end
</h2>
<div class="Standard">
Likewise, we need to recognize when a chunk ends.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.1">8.2.1</a> lstlistings
</h3>
<div class="Standard">
The 
<span class="code">
e
</span> in 
<span class="code">
[e]end{lislisting}
</span> is surrounded by square brackets so that when this document is processed, this chunk doesn't terminate early when the lstlistings package recognizes it's own end-string! 
<span class="greyedout">
This doesn't make sense as the regex is anchored with ^, which this line does not begin with!
</span>
</div>
<div class="Chunk">
recognize-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">/^\\[e]nd{lstlisting}|^\\[e]nd{Chunk}/ {
  chunking=0;
  active_chunk="";
  next;
}
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.2">8.2.2</a> noweb
</h3>
<div class="Chunk">
recognize-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">/^@ *$/ {
  chunking=0;
  active_chunk="";
}
</code>
</div>
</div>
</div>
<div class="Standard">
All other recognizers are only of effect if we are chunking; there's no point in looking at lines if they aren't part of a chunk, so we just ignore them as efficiently as we can.
</div>
<div class="Chunk">
recognize-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">! chunking { next; }
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.3">8.3</a> Chunk contents
</h2>
<div class="Standard">
Chunk contents are any lines read while 
<span class="code">
chunking
</span> is true. Some chunk contents are special in that they refer to other chunks, and will be replaced by the contents of these chunks when the file is generated.
</div>
<div class="Standard">
<a class="Label" name="sub:ORS-chunk-text"> </a>We add the output record separator 
<span class="code">
ORS
</span> to the line now, because we will set 
<span class="code">
ORS
</span> to the empty string when we generate the output<span class="FootMarker"> [L->] </span>
<span class="Foot">
<span class="FootMarker">[->L] </span>So that we can print partial lines using 
<span class="code">
print
</span> instead of 
<span class="code">
printf
</span>
</span>.
</div>
<div class="Chunk">
recognize-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">length(active_chunk) {
  =&lt;\chunkref{process-chunk-tabs}&gt;
  =&lt;\chunkref{process-chunk}&gt;
}
</code>
</div>
</div>
</div>
<div class="Standard">
If a chunk just consisted of plain text, we could handle the chunk like this:
</div>
<div class="Chunk">
process-chunk-simple
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">chunk_line(active_chunk, $0 ORS);
</code>
</div>
</div>
</div>
<div class="Standard">
but in fact a chunk can include references to other chunks. Chunk includes are traditionally written as 
<span class="code">
&lt;&lt;chunk-name&gt;&gt;
</span>, but we support other variations.
</div>
<div class="Standard">
However, we also process tabs at this point, a tab at input can be replaced by a number of spaces defined by the 
<span class="code">
tabs
</span> variable, set by the 
<span class="code">
-T
</span> option. Of course this is poor tab behaviour, we should probably have the option to use proper counted tab-stops and process this on output.
</div>
<div class="Chunk">
process-chunk-tabs
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (length(tabs)) {
  gsub("\t", tabs);
}
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.3.1">8.3.1</a> <a class="Label" name="sub:lstlistings-includes"> </a>lstlistings
</h3>
<div class="Standard">
If 
<span class="code">
\lstset{escapeinside={=&lt;}{&gt;}}
</span> is set, then we can use 
<span class="code">
=&lt;\chunkref{ chunk-name}&gt;
</span> in listings. The sequence 
<span class="code">
=&lt;
</span> was chosen because:
</div>
<ol>

<li>
it is a better mnemonic than 
<span class="code">
&lt;&lt;chunk-name&gt;&gt;
</span> in that the = sign signifies equivalent or substitutability, 
</li>
<li>
and because =&lt; is not valid in C or in any language I can think of 
</li>
<li>
and also because lstlistings doesn't like 
<span class="code">
&gt;&gt;
</span> as an end delimiter for the <i>texcl</i> escape, so we must make do with a single 
<span class="code">
&gt;
</span>, which is better matched by 
<span class="code">
=&lt;
</span> than 
<span class="code">
&lt;&lt;
</span>.
</li>
</ol>
<div class="Standard">
Unfortunately  the 
<span class="code">
=&lt;...&gt;
</span> that we use re-enters a LaTeX parsing mode in which some characters are special, e.g. 
<span class="code">
# \
</span>, and so these cause trouble if used in arguments to 
<span class="code">
\chunkref
</span>. At some point I must fix the LaTeX command 
<span class="code">
\chunkref
</span> so that it can accept these literally, but until then, when writing chunkref argumemts that need these characters, I must use the forms 
<span class="code">
\textbackslash{}
</span> and 
<span class="code">
\#
</span>; so I also define a hacky chunk 
<span class="code">
delatex
</span> whose purpose it is to remove these from any arguments parsed by fangle, and used further on.
</div>
<div class="Chunk">
delatex,params=text
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># FILTHY HACK
gsub("\\\\#", "#", ${text});
gsub("\\\\textbackslash{}", "\\", ${text});
</code>
</div>
</div>
</div>
<div class="Standard">
As each chunk line may contain more than one chunk include, we will split out chunk includes in an iterative fashion<span class="FootMarker"> [M->] </span>
<span class="Foot">
<span class="FootMarker">[->M] </span>Contrary to our use of 
<span class="code">
split
</span> when substituting parameters in chapter <a class="Reference" href="#Here-we-split">?</a>
</span>.
</div>
<div class="Standard">
First, as long as the chunk contains a 
<span class="code">
\chunkref
</span> command we take as much as we can up to the first 
<span class="code">
\chunkref
</span> command.
</div>
<div class="Chunk">
process-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">chunk = $0;
indent = 0;
while(match(chunk, 
            "([=]&lt;\\\\chunkref{([^}&gt;]*)}(\\(.*\\)|)&gt;|&lt;&lt;([a-zA-Z_][-a-zA-Z0-9_]*)&gt;&gt;)", 
            line)\
) {
  chunklet = substr(chunk, 1, RSTART - 1);
</code>
</div>
</div>
</div>
<div class="Standard">
We keep track of the indent count, by counting the number of literal characters found. We can then preserve this indent on each output line when multi-line chunks are expanded.
</div>
<div class="Standard">
We then process this first part literal text, and set the chunk which is still to be processed to be the text after the 
<span class="code">
\chunkref
</span> command, which we will process next as we continue around the loop.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  indent += length(chunklet);
  chunk_line(active_chunk, chunklet);
  chunk = substr(chunk, RSTART + RLENGTH);
</code>
</div>
</div>
</div>
<div class="Standard">
We then consider the type of chunk command we have found, whether it is the fangle style command beginning with 
<span class="code">
=&lt;
</span> or the older notangle style beginning with 
<span class="code">
&lt;&lt;
</span>. 
</div>
<div class="Standard">
Fangle chunks may have parameters contained within square brackets. These will be matched in 
<span class="code">
line[3]
</span> and are considered at this stage of processing to be part of the name of the chunk to be included.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  if (substr(line[1], 1, 1) == "=") {
    # chunk name up to }
	=&lt;\chunkref{delatex}(line[3])&gt;
    chunk_include(active_chunk, line[2] line[3], indent);
  } else if (substr(line[1], 1, 1) == "&lt;") {
    chunk_include(active_chunk, line[4], indent);
  } else {
    error("Unknown chunk fragment: " line[1]);
  }
</code>
</div>
</div>
</div>
<div class="Standard">
The loop will continue until there are no more chunkref statements in the text, at which point we process the final part of the chunk.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">}
chunk_line(active_chunk, chunk);
</code>
</div>
</div>
</div>
<div class="Standard">
<a class="Label" name="lone-newline"> </a>We add the newline character as a chunklet on it's own, to make it easier to detect new lines and thus manage indentation when processing the output.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">chunk_line(active_chunk, "\n");
</code>
</div>
</div>
</div>
<div class="Standard">
We will also permit a chunk-part number to follow in square brackets, so that 
<span class="code">
=&lt;\chunkref{chunk-name[1]}&gt;
</span> will refer to the first part only. This can make it easy to include a C function prototype in a header file, if the first part of the chunk is just the function prototype without the trailing semi-colon. The header file would include the prototype with the trailing semi-colon, like this:
</div>
<pre class="LyX-Code">
=&lt;\chunkref{chunk-name[1]}&gt;;
</pre>
<div class="Standard">
This is handled in section <a class="Reference" href="#sub:Chunk-parts">10.1.1?</a>
</div>
<div class="Standard">
We should perhaps introduce a notion of language specific chunk options; so that perhaps we could specify:
</div>
<pre class="LyX-Code">
=&lt;\chunkref{chunk-name[function-declaration]}&gt;;
</pre>
<div class="Standard">
which applies a transform 
<span class="code">
function-declaration
</span> to the chunk --- which in this case would extract a function prototype from a function.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-9">9</a> Processing Options
</h1>
<div class="Standard">
At the start, first we set the default options.
</div>
<div class="Chunk">
default-options
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">debug=0;
linenos=0;
notangle_mode=0;
root="*";
tabs = "";
</code>
</div>
</div>
</div>
<div class="Standard">
Then we use getopt the standard way, and null out ARGV afterwards in the normal AWK fashion.
</div>
<div class="Chunk">
read-options
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">Optind = 1    # skip ARGV[0]
while(getopt(ARGC, ARGV, "R:LdT:hr")!=-1) {
  =&lt;\chunkref{handle-options}&gt;
}
for (i=1; i&lt;Optind; i++) { ARGV[i]=""; }
</code>
</div>
</div>
</div>
<div class="Standard">
This is how we handle our options:
</div>
<div class="Chunk">
handle-options
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (Optopt == "R") root = Optarg;
else if (Optopt == "r") root="";
else if (Optopt == "L") linenos = 1;
else if (Optopt == "d") debug = 1;
else if (Optopt == "T") tabs = indent_string(Optarg+0);
else if (Optopt == "h") help();
else if (Optopt == "?") help();
</code>
</div>
</div>
</div>
<div class="Standard">
We do all of this at the beginning of the program
</div>
<div class="Chunk">
begin
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">BEGIN {
  =&lt;\chunkref{constants}&gt;
  =&lt;\chunkref{mode-definitions}&gt;
  =&lt;\chunkref{default-options}&gt;

  =&lt;\chunkref{read-options}&gt;
}
</code>
</div>
</div>
</div>
<div class="Standard">
And have a simple help function
</div>
<div class="Chunk">
help()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function help() {
  print "Usage:"
  print "  fangle [-L] -R&lt;rootname&gt; [source.tex ...]"
  print "  fangle -r [source.tex ...]"
  print "  If the filename, source.tex is not specified then stdin is used"
  print
  print "-L causes the C statement: #line &lt;lineno&gt; \"filename\"" to be issued"
  print "-R causes the named root to be written to stdout"
  print "-r lists all roots in the file (even those used elsewhere)"
  exit 1;
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-10">10</a> Generating the output
</h1>
<div class="Standard">
We generate output by calling output_chunk, or listing the chunk names.
</div>
<div class="Chunk">
generate-output
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (length(root)) output_chunk(root);
else output_chunk_names();
</code>
</div>
</div>
</div>
<div class="Standard">
We also have some other output debugging:
</div>
<div class="Chunk">
debug-output
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (debug) {
  print "------ chunk names "
  output_chunk_names();
  print "====== chunks"
  output_chunks();
  print "++++++ debug"
  for (a in chunks) {
    print a "=" chunks[a];
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">
We do both of these at the end. We also set 
<span class="code">
ORS=""
</span> because each chunklet is not necessarily a complete line, and we already added 
<span class="code">
ORS
</span> to each input line in section <a class="Reference" href="#sub:ORS-chunk-text">?</a>.
</div>
<div class="Chunk">
end
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">END {
  =&lt;\chunkref{debug-output}&gt;
  ORS="";
  =&lt;\chunkref{generate-output}&gt;
}
</code>
</div>
</div>
</div>
<div class="Standard">
We write chunk names like this. If we seem to be running in notangle compatibility mode, then we enclose the name like this 
<span class="code">
&lt;&lt;name&gt;&gt;
</span> the same way notangle does:
</div>
<div class="Chunk">
output_chunk_names()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function output_chunk_names(   c, prefix, suffix) 
{
  if (notangle_mode) {
    prefix="&lt;&lt;";
    suffix="&gt;&gt;";
  }
  for (c in chunk_names) {
    print prefix c suffix "\n";
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">
This function would write out all chunks
</div>
<div class="Chunk">
output_chunks()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function output_chunks(  a) 
{
  for (a in chunk_names) {
    output_chunk(chunk_names[a]);
  }
}

function output_chunk(chunk) {
  newline = 1;
  lineno_needed = linenos;

  write_chunk(chunk);
}

</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.1">10.1</a> Assembling the chunks
</h2>
<div class="Standard">

<span class="code">
chunk_path
</span> holds a string consisting of the names of all the chunks that resulted in this chunk being output. It should probably also contain the source line numbers at which each inclusion also occured.
</div>
<div class="Chunk">
write_chunk()
</div>
<div class="Standard">
We first initialize the mode tracker for this chunk.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function write_chunk(chunk_name) {
  =&lt;\chunkref{awk-delete-array}(context)&gt;
  return write_chunk_r(chunk_name, context);
}
</code>
</div>
</div>
</div>
<div class="Chunk">
write_chunk(),emph={chunk_path}
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function write_chunk_r(chunk_name, context, indent, tail,
  # optional vars
  chunk_path, chunk_args, 
  s, r, src, new_src, 
  # local vars
  chunk_params, part, max_part, part_line, frag, max_frag, text, 
  chunklet, only_part, call_chunk_args)
{
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.1.1">10.1.1</a> <a class="Label" name="sub:Chunk-parts"> </a>Chunk parts
</h3>
<div class="Standard">
As mentioned in section <a class="Reference" href="#sub:lstlistings-includes">8.3.1?</a>, a chunk name may contain a part specifier in square brackets, limiting the parts that should be emitted.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  if (match(chunk_name, "^(.*)\\[([0-9]*)\\]$", chunk_name_parts)) {
    chunk_name = chunk_name_parts[1];
    only_part = chunk_name_parts[2];
  }
</code>
</div>
</div>
</div>
<div class="Standard">
We then create a mode tracker 
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  =&lt;\chunkref{new-mode-tracker}(context, chunks[chunk_name, "language"], "")&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We extract into 
<span class="code">
chunk_params
</span> the names of the parameters that this chunk accepts, whose values were (optionally) passed in 
<span class="code">
chunk_args
</span>.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  split(chunks[chunk_name, "params"], chunk_params, " *; *");
</code>
</div>
</div>
</div>
<div class="Standard">
To assemble a chunk, we write out each part.
</div>
<div class="Chunk">
write_chunk()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  if (! (chunk_name in chunk_names)) {
    error(sprintf(_"The root module &lt;&lt;%s&gt;&gt; was not defined.\nUsed by: %s",\
                  chunk_name, chunk_path));
  }

  max_part = chunks[chunk_name, "part"];
  for(part = 1; part &lt;= max_part; part++) {
    if (! only_part || part == only_part) {
      =&lt;\chunkref{write-part}&gt;
    }
  }
  if (! finalize_mode_tracker(context)) {
    error(sprintf(_"Module %s did not close context properly.\nUsed by: %s\n", chunk_name, chunk_path));
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">
A part can either be a chunklet of lines, or an include of another chunk.
</div>
<div class="Standard">
Chunks may also have parameters, specified in LaTeX style with braces after the chunk name --- looking like this in the document: 
<span class="code">
chunkname{param1, param2}
</span>. Arguments are passed in square brackets: 
<span class="code">
\chunkref{chunkname}[arg1, arg2]
</span>.
</div>
<div class="Standard">
Before we process each part, we check that the source position hasn't changed unexpectedly, so that we can know if we need to output a new file-line directive.
</div>
<div class="Chunk">
write-part
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{check-source-jump}&gt;

chunklet = chunks[chunk_name, "part", part];
if (chunks[chunk_name, "part", part, "type"] == part_type_chunk) {
  =&lt;\chunkref{write-included-chunk}&gt;
} else if (chunklet SUBSEP "line" in chunks) {
  =&lt;\chunkref{write-chunklets}&gt;
} else {
  # empty last chunklet
}
</code>
</div>
</div>
</div>
<div class="Standard">
To write an included chunk, we must detect any optional chunk arguments in parenthesis. Then we recurse calling 
<span class="Flex">
write_chunk()
</span>.
</div>
<div class="Chunk">
write-included-chunk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (match(chunklet, "^([^\\[\\(]*)\\((.*)\\)$", chunklet_parts)) {
  chunklet = chunklet_parts[1];
  parse_chunk_args("c-like", chunklet_parts[2], call_chunk_args, "(");
  for (c in call_chunk_args) {
    call_chunk_args[c] = expand_chunk_args(call_chunk_args[c], chunk_params, chunk_args);
  }
} else {
  split("", call_chunk_args);
}
# update the transforms arrays
new_src = mode_escaper(context, s, r, src);
write_chunk_r(chunklet, context,
            chunks[chunk_name, "part", part, "indent"] indent,
            chunks[chunk_name, "part", part, "tail"],
            chunk_path "\n         " chunk_name,
            call_chunk_args,
			s, r, new_src);
</code>
</div>
</div>
</div>
<div class="Standard">
Before we output a chunklet of lines, we first emit the file and line number if we have one, and if it is safe to do so. 
</div>
<div class="Standard">
Chunklets are generally broken up by includes, so the start of a chunklet is a good place to do this. Then we output each line of the chunklet.
</div>
<div class="Standard">
When it is not safe, such as in the middle of a multi-line macro definition, 
<span class="code">
lineno_suppressed
</span> is set to true, and in such a case we note that we want to emit the line statement when it is next safe.
</div>
<div class="Chunk">
write-chunklets
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">max_frag = chunks[chunklet, "line"];
for(frag = 1; frag &lt;= max_frag; frag++) {
  =&lt;\chunkref{write-file-line}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
We then extract the chunklet text and expand any arguments.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">
  text = chunks[chunklet, frag];
 
  /* check params */
  text = expand_chunk_args(text, chunk_params, chunk_args);
</code>
</div>
</div>
</div>
<div class="Standard">
If the text is a single newline (which we keep separate - see <a class="Reference" href="#lone-newline">?</a>) then we increment the line number. In the case where this is the last line of a chunk and it is not a top-level chunk we replace the newline with an empty string --- because the chunk that included this chunk will have the newline at the end of the line that included this chunk.
</div>
<div class="Standard">
We also note by 
<span class="code">
newline = 1
</span> that we have started a new line, so that indentation can be managed with the following piece of text.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">
 if (text == "\n") {
    lineno++;
    if (part == max_part &amp;&amp; frag == max_frag &amp;&amp; length(chunk_path)) {
      text = "";
      break;
    } else {
      newline = 1;
    }
</code>
</div>
</div>
</div>
<div class="Standard">
If this text does not represent a newline, but we see that we are the first piece of text on a newline, then we prefix our text with the current indent. NOTE: 
<span class="code">
newline
</span> is a global output-state variable, but the 
<span class="code">
indent
</span> is not. 
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  } else if (length(text) || length(tail)) {
    if (newline) text = indent text;
    newline = 0;
  }

</code>
</div>
</div>
</div>
<div class="Standard">
Tail will soon no longer be relevant once mode-detection is in place.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  text = text tail;
  mode_tracker(context, text);
  print transform_escape(s, r, text, src);
</code>
</div>
</div>
</div>
<div class="Standard">
If a line ends in a backslash --- suggesting continuation --- then we supress outputting file-line as it would probably break the continued lines. 
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  if (linenos) {
    lineno_suppressed = substr(lastline, length(lastline)) == "\\";
  }
}
</code>
</div>
</div>
</div>
<div class="Standard">
Of course there is no point in actually outputting the source filename and line number (file-line) if they don't say anything new! We only need to emit them if they aren't what is expected, or if we we not able to emit one when they had changed.
</div>
<div class="Chunk">
write-file-line
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (newline &amp;&amp; lineno_needed &amp;&amp; ! lineno_suppressed) {
  filename = a_filename;
  lineno = a_lineno;
  print "#line " lineno " \"" filename "\"\n"
  lineno_needed = 0;
}
</code>
</div>
</div>
</div>
<div class="Standard">
We check if a new file-line is needed by checking if the source line matches what we (or a compiler) would expect. 
</div>
<div class="Chunk">
check-source-jump
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">if (linenos &amp;&amp; (chunk_name SUBSEP "part" SUBSEP part SUBSEP "FILENAME" in chunks)) {
  a_filename = chunks[chunk_name, "part", part, "FILENAME"];
  a_lineno = chunks[chunk_name, "part", part, "LINENO"];
  if (a_filename != filename || a_lineno != lineno) {
    lineno_needed++;
  }
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-11">11</a> Storing chunks
</h1>
<div class="Standard">
Awk has pretty limited data structures, so we will use two main hashes. Uninterrupted sequences of a chunk will be stored in 
<span class="code">
chunklets
</span> and the chunklets used in a chunk will be stored in 
<span class="code">
chunks
</span>.
</div>
<div class="Chunk">
constants
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">part_type_chunk=1;
SUBSEP=",";
</code>
</div>
</div>
</div>
<div class="Standard">
The 
<span class="code">
params
</span> mentioned are not chunk parameters for parameterized chunks, as mentioned in <a class="Reference" href="#cha:Chunk Arguments">?</a>, but the lstlistings style parameters used in the 
<span class="code">
\Chunk
</span> command<span class="FootMarker"> [N->] </span>
<span class="Foot">
<span class="FootMarker">[->N] </span>The 
<span class="code">
params
</span> parameter is used to hold the parameters for parameterized chunks
</span>.
</div>
<div class="Chunk">
chunk-storage-functions
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function new_chunk(chunk_name, params,
  # local vars
  p, append )
{
  # HACK WHILE WE CHANGE TO ( ) for PARAM CHUNKS
  gsub("\\(\\)$", "", chunk_name);
  if (! (chunk_name in chunk_names)) {
    if (debug) print "New chunk " chunk_name;
    chunk_names[chunk_name];
    for (p in params) {
      chunks[chunk_name, p] = params[p];
    }
    if ("append" in params) {
      append=params["append"];
      if (! (append in chunk_names)) {
        warning("Chunk " chunk_name " is appended to chunk " append " which is not defined yet");
        new_chunk(append);
      }
      chunk_include(append, chunk_name);
      chunk_line(append, ORS);
    }
  }
  active_chunk = chunk_name;
  prime_chunk(chunk_name);
}
</code>
</div>
</div>
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">
function prime_chunk(chunk_name)
{
  chunks[chunk_name, "part", ++chunks[chunk_name, "part"] ] = \
         chunk_name SUBSEP "chunklet" SUBSEP "" ++chunks[chunk_name, "chunklet"];
  chunks[chunk_name, "part", chunks[chunk_name, "part"], "FILENAME"] = FILENAME;
  chunks[chunk_name, "part", chunks[chunk_name, "part"], "LINENO"] = FNR + 1;
}

function chunk_line(chunk_name, line){
  chunks[chunk_name, "chunklet", chunks[chunk_name, "chunklet"],
         ++chunks[chunk_name, "chunklet", chunks[chunk_name, "chunklet"], "line"]  ] = line;
}

</code>
</div>
</div>
</div>
<div class="Standard">
Chunk include represents a <i>chunkref</i> statement, and stores the requirement to include another chunk. The parameter indent represents the quanity of literal text characters that preceded this <i>chunkref</i> statement and therefore by how much additional lines of the included chunk should be indented.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function chunk_include(chunk_name, chunk_ref, indent, tail)
{
  chunks[chunk_name, "part", ++chunks[chunk_name, "part"] ] = chunk_ref;
  chunks[chunk_name, "part", chunks[chunk_name, "part"], "type" ] = part_type_chunk;
  chunks[chunk_name, "part", chunks[chunk_name, "part"], "indent" ] = indent_string(indent);
  chunks[chunk_name, "part", chunks[chunk_name, "part"], "tail" ] = tail;
  prime_chunk(chunk_name);
}

</code>
</div>
</div>
</div>
<div class="Standard">
The indent is calculated by indent_string, which may in future convert some spaces into tab characters. This function works by generating a printf padded format string, like 
<span class="code">
%22s
</span> for an indent of 22, and then printing an empty string using that format.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function indent_string(indent) {
  return sprintf("%" indent "s", "");
}
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-12">12</a> <a class="Label" name="cha:getopt"> </a>getopt
</h1>
<div class="Standard">
I use Arnold Robbins public domain getopt (1993 revision). This is probably the same one that is covered in chapter 12 of "Edition 3 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk" but as that is licensed under the GNU Free Documentation License, Version 1.3, which conflicts with the GPL3, I can't use it from there (or it's accompanying explanations), so I do my best to explain how it works here.
</div>
<div class="Standard">
The getopt.awk header is:
</div>
<div class="Chunk">
getopt.awk-header,language=awk,morestring=[b]{/},morekeywords=else
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># getopt.awk --- do C library getopt(3) function in awk
#
# Arnold Robbins, arnold@skeeve.com, Public Domain
#
# Initial version: March, 1991
# Revised: May, 1993

</code>
</div>
</div>
</div>
<div class="Standard">
The provided explanation is:
</div>
<div class="Chunk">
getopt.awk-notes
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    ?      for unrecognized option
#    &lt;c&gt;    a character representing the current option

# Private Data:
#    _opti  -- index in multi-flag option, e.g., -abc

</code>
</div>
</div>
</div>
<div class="Standard">
The function follows. The final two parameters, 
<span class="code">
thisopt
</span> and 
<span class="code">
i
</span> are local variables and not parameters --- as indicated by the multiple spaces preceding them. Awk doesn't care, the multiple spaces are a convention to help us humans.
</div>
<div class="Chunk">
getopt.awk-getopt()
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1
    if (argv[Optind] == "--") {  # all done
        Optind++
        _opti = 0
        return -1
    } else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) {
        _opti = 0
        return -1
    }
    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf("%c -- invalid option\n",
                                  thisopt) &gt; "/dev/stderr"
        if (_opti &gt;= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return "?"
    }
</code>
</div>
</div>
</div>
<div class="Standard">
At this point, the option has been found and we need to know if it takes any arguments.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">    if (substr(options, i + 1, 1) == ":") {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) &gt; 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = ""
    if (_opti == 0 || _opti &gt;= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}
</code>
</div>
</div>A test program is built in, too
</div>
<div class="Chunk">
getopt.awk-begin
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">BEGIN {
    Opterr = 1    # default is to diagnose
    Optind = 1    # skip ARGV[0]
    # test program
    if (_getopt_test) {
        while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
            printf("c = &lt;%c&gt;, optarg = &lt;%s&gt;\n",
                                       _go_c, Optarg)
        printf("non-option arguments:\n")
        for (; Optind &lt; ARGC; Optind++)
            printf("\tARGV[%d] = &lt;%s&gt;\n",
                                    Optind, ARGV[Optind])
    }
}
</code>
</div>
</div>
</div>
<div class="Standard">
The entire getopt.awk is made out of these chunks in order
</div>
<div class="Chunk">
getopt.awk
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">=&lt;\chunkref{getopt.awk-header}&gt;

=&lt;\chunkref{getopt.awk-notes}&gt;
=&lt;\chunkref{getopt.awk-getopt()}&gt;
=&lt;\chunkref{getopt.awk-begin}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
Although we only want the header and function:
</div>
<div class="Chunk">
getopt
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># try: locate getopt.awk for the full original file
# as part of your standard awk installation
=&lt;\chunkref{getopt.awk-header}&gt;

=&lt;\chunkref{getopt.awk-getopt()}&gt;
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-13">13</a> Fangle LaTeX source code
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-13.1">13.1</a> fangle module
</h2>
<div class="Standard">
Here we define a Lyx .module file that makes it convenient to use LyX for writing such literate programs.
</div>
<div class="Standard">
This file 
<span class="code">
./fangle.module
</span> can be installed in your personal 
<span class="code">
.lyx/layouts folder
</span>. You will need to Tools Reconfigure so that LyX notices it. It adds a new format Chunk, which should precede every listing and contain the chunk name. 
</div>
<div class="Chunk">
./fangle.module,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">#\DeclareLyXModule{Fangle Literate Listings}
#DescriptionBegin
#  Fangle literate listings allow one to write
#   literate programs after the fashion of noweb, but without having
#   to use noweave to generate the documentation. Instead the listings
#   package is extended in conjunction with the noweb package to implement
#   to code formating directly as latex.
#  The fangle awk script
#DescriptionEnd

Format 11

AddToPreamble
=&lt;\chunkref{./fangle.sty}&gt;
EndPreamble

=&lt;\chunkref{chunkstyle}&gt;

=&lt;\chunkref{chunkref}&gt;
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.1.1">13.1.1</a> The Chunk style
</h3>
<div class="Standard">
The purpose of the <span class="versalitas">chunk</span> style is to make it easier for LyX users to provide the name to 
<span class="code">
\lstlistings
</span>. Normally this requires right-clicking on the listing, choosing settings, advanced, and then typing 
<span class="code">
name=chunk-name
</span>. This has the further disadvantage that the name (and other options) are not generally visible during document editing.
</div>
<div class="Standard">
The chunk style is defined as a LaTeX command, so that all text on the same line is passed to the LaTeX command 
<span class="code">
Chunk
</span>. This makes it easy to parse using 
<span class="code">
fangle
</span>, and easy to pass these options on to the listings package. The first word in a chunk section should be the chunk name, and will have 
<span class="code">
name=
</span> prepended to it. Any other words are accepted arguments to 
<span class="code">
\lstset
</span>.
</div>
<div class="Standard">
We set PassThru to 1 because the user is actually entering raw latex.
</div>
<div class="Chunk">
chunkstyle
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">Style Chunk
  LatexType             Command
  LatexName             Chunk
  Margin                First_Dynamic
  LeftMargin            Chunk:xxx
  LabelSep              xx
  LabelType             Static
  LabelString           "Chunk:"
  Align                 Left
  PassThru              1

</code>
</div>
</div>
</div>
<div class="Standard">
To make the label very visible we choose a larger font coloured red.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  LabelFont
    Family              Sans
    Size                Large
    Series              Bold
    Shape               Italic
    Color               red
  EndFont
End
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.1.2">13.1.2</a> The chunkref style
</h3>
<div class="Standard">
We also define the Chunkref style which can be used to express cross references to chunks.
</div>
<div class="Chunk">
chunkref
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">InsetLayout Chunkref
  LyxType               charstyle
  LatexType             Command
  LatexName             chunkref
  PassThru              1
  LabelFont             
    Shape               Italic
    Color               red
  EndFont
End
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.2">13.2</a> <a class="Label" name="sec:Latex-Macros"> </a>Latex Macros
</h2>
<div class="Standard">
We require the <span class="versalitas">listings</span>, <span class="versalitas">noweb</span> and <span class="versalitas">xargs</span> packages. As noweb defines it's own 
<span class="code">
\code
</span> environment, we re-define the one that LyX logical markup module expects here.
</div>
<div class="Chunk">
./fangle.sty,language=tex,basicstyle=\ttfamily
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\usepackage{listings}%
\usepackage{noweb}%
\usepackage{xargs}%
\renewcommand{\code}[1]{\texttt{#1}}%
</code>
</div>
</div>
</div>
<div class="Standard">
We also define a 
<span class="code">
CChunk
</span> macro, for use as: 
<span class="code">
\begin{CChunk}
</span> which will need renaming to 
<span class="code">
\begin{Chunk}
</span> when I can do this without clashing with 
<span class="code">
\Chunk
</span>.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\lstnewenvironment{Chunk}{\relax}{\relax}%
</code>
</div>
</div>
</div>
<div class="Standard">
We also define a suitable 
<span class="code">
\lstset
</span> of parameters that suit the literate programming style after the fashion of <span class="versalitas">noweave</span>.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\lstset{numbers=left, stepnumber=5, numbersep=5pt,
        breaklines=false,basicstyle=\ttfamily,
        numberstyle=\tiny, language=C}%
</code>
</div>
</div>
</div>
<div class="Standard">
We also define a notangle-like mechanism for <i>escaping</i> to LaTeX from the listing, and by which we can refer to other listings. We declare the 
<span class="code">
=&lt;...&gt;
</span> sequence to contain LaTeX code, and include another like this chunk: 
<span class="code">
=&lt;\chunkref{chunkname}&gt;
</span>. However, because 
<span class="code">
=&lt;...&gt;
</span> is already defined to contain LaTeX code for this document --- this is a <span class="versalitas">fangle</span> document after all --- the code fragment below effectively contains the LaTeX code: 
<span class="code">
}{
</span>. To avoid problems with document generation, I had to declare an lstlistings property: 
<span class="code">
escapeinside={}
</span> for this listing only; which in LyX was done by right-clicking the listings inset, choosing 
<span class="code">
settings
</span>&nbsp;?&nbsp;
<span class="code">
advanced
</span>.
</div>
<div class="Standard">

</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\lstset{escapeinside={=&lt;}{&gt;}}%
</code>
</div>
</div>
</div>
<div class="Standard">
Although our macros will contain the @ symbol, they will be included in a 
<span class="code">
\makeatletter
</span> section by LyX; however we keep the commented out 
<span class="code">
\makeatletter
</span> as a reminder. The listings package likes to centre the titles, but noweb titles are specially formatted and must be left aligned. The simplest way to do this turned out to be by removing the definition of 
<span class="code">
\lst@maketitle
</span>. This may interact badly if other listings want a regular title or caption. We remember the old maketitle in case we need it.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">%\makeatletter
%somehow re-defining maketitle gives us a left-aligned title
%which is extactly what our specially formatted title needs!
\global\let\fangle@lst@maketitle\lst@maketitle%
\global\def\lst@maketitle{}%
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.2.1">13.2.1</a> <a class="Label" name="sub:The-chunk-command"> </a>The chunk command
</h3>
<div class="Standard">
Our chunk command accepts one argument, and calls 
<span class="code">
\ltset
</span>. Although 
<span class="code">
\ltset
</span> will note the name, this is erased when the next 
<span class="code">
\lstlisting
</span> starts, so we make a note of this in 
<span class="code">
\lst@chunkname
</span> and restore in in lstlistings Init hook.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\def\Chunk#1{%
  \lstset{title={\fanglecaption},name=#1}%
  \global\edef\lst@chunkname{\lst@intname}%
}%
\def\lst@chunkname{\empty}%
</code>
</div>
</div>
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-13.2.1.1">13.2.1.1</a> Chunk parameters
</h4>
<div class="Standard">
Fangle permits parameterized chunks, and requires the paramters to be specified as listings options. The fangle script uses this, and although we don't do anything with these in the LaTeX code right now, we need to stop the listings package complaining.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\lst@Key{params}\relax{\def\fangle@chunk@params{#1}}%
</code>
</div>
</div>
</div>
<div class="Standard">
As it is common to define a chunk which then needs appending to another chunk, and annoying to have to declare a single line chunk to manage the include, we support an 
<span class="code">
append=
</span> option. 
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\lst@Key{append}\relax{\def\fangle@chunk@append{#1}}%
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.2.2">13.2.2</a> The noweb styled caption
</h3>
<div class="Standard">
We define a public macro 
<span class="code">
\fanglecaption
</span> which can be set as a regular title. By means of 
<span class="code">
\protect
</span>, It expands to 
<span class="code">
\fangle@caption
</span> at the appriate time when the caption is emitted.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\def\fanglecaption{\protect\newfangle@caption}%
</code>
</div>
</div>
</div>
<div class="Standard">

<div class="float">

<div class="figure">

<div>
22c  ?<i>some-chunk</i> 19b?<span class="formula"> ?  + </span>      <span class="formula">?</span>22b 24d<span class="formula">?</span><span class="footnotesize">In this example, the current chunk is 22c, and therefore the third chunk on page 22.</span><span class="footnotesize">It's name is <i>some-chunk</i>. </span><span class="footnotesize">The first chunk with this name (19b) occurs as the second chunk on page 19.</span><span class="footnotesize">The previous chunk (22d) with the same name is the second chunk on page 22.</span><span class="footnotesize">The next chunk (24d) is the fourth chunk on page 24.</span>
<div class="caption">
Figure 13.1 noweb heading
</div>
</div>
</div>
</div>The general noweb output format compactly identifies the current chunk, and references to the first chunk, and the previous and next chunks that have the same name. 
</div>
<div class="Standard">
This means that we need to keep a counter for each chunk-name, that we use to count chunks of the same name. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.2.3">13.2.3</a> The chunk counter
</h3>
<div class="Standard">
It would be natural to have a counter for each chunk name, but TeX would soon run out of counters<span class="FootMarker"> [O->] </span>
<span class="Foot">
<span class="FootMarker">[->O] </span>...soon <i>did</i> run out of counters and so I had to re-write the LaTeX macros to share a counter as described here
</span>, so we have one counter which we save at the end of a chunk and restore at the beginning of a chunk.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\newcounter{fangle@chunkcounter}%
</code>
</div>
</div>
</div>
<div class="Standard">
We construct the name of this variable to store the counter to be the text 
<span class="code">
lst-chunk-
</span> prefixed onto the chunks own name, and store it in 
<span class="code">
\chunkcount
</span>. 
</div>
<div class="Standard">
We save the counter like this:
</div>
<div class="Chunk">
save-counter
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\global\expandafter\edef\csname \chunkcount\endcsname{\arabic{fangle@chunkcounter}}%
</code>
</div>
</div>
</div>
<div class="Standard">
and restore the counter like this:
</div>
<div class="Chunk">
restore-counter
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
</code>
</div>
</div>
</div>
<div class="Chunk">
./fangle.sty
</div>
<div class="Standard">
If there does not already exist a variable whose name is stored in 
<span class="code">
\chunkcount
</span>, then we know we are the first chunk with this name, and then define a counter. 
</div>
<div class="Standard">
Although chunks of the same name share a common counter, they must still be distinguished. We use is the internal name of the listing, suffixed by the counter value. So the first chunk might be 
<span class="code">
something-1
</span> and the second chunk be 
<span class="code">
something-2
</span>, etc.
</div>
<div class="Standard">
We also calculate the name of the previous chunk if we can (before we increment the chunk counter). If this is the first chunk of that name, then 
<span class="code">
\prevchunkname
</span> is set to 
<span class="code">
\relax
</span> which the noweb package will interpret as not existing.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\def\fangle@caption{%
  \edef\chunkcount{lst-chunk-\lst@intname}%
  \@ifundefined{\chunkcount}{%
    \expandafter\gdef\csname \chunkcount\endcsname{0}%
    \setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
    \let\prevchunkname\relax%
  }{%
    \setcounter{fangle@chunkcounter}{\csname \chunkcount\endcsname}%
    \edef\prevchunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  }%
</code>
</div>
</div>
</div>
<div class="Standard">
After incrementing the chunk counter, we then define the name of this chunk, as well as the name of the first chunk.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  \addtocounter{fangle@chunkcounter}{1}%
  \global\expandafter\edef\csname \chunkcount\endcsname{\arabic{fangle@chunkcounter}}%
  \edef\chunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  \edef\firstchunkname{\lst@intname-1}%
</code>
</div>
</div>
</div>
<div class="Standard">
We now need to calculate the name of the next chunk. We do this by temporarily skipping the counter on by one; however there may not actually be another chunk with this name! We detect this by also defining a label for each chunk based on the chunkname. If there is a next chunkname then it will define a label with that name. As labels are persistent, we can at least tell the second time LaTeX is run. If we don't find such a defined label then we define 
<span class="code">
\nextchunkname
</span> to 
<span class="code">
\relax
</span>.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  \addtocounter{fangle@chunkcounter}{1}%
  \edef\nextchunkname{\lst@intname-\arabic{fangle@chunkcounter}}%
  \@ifundefined{r@label-\nextchunkname}{\let\nextchunkname\relax}{}%
</code>
</div>
</div>
</div>
<div class="Standard">
The noweb package requires that we define a 
<span class="code">
\sublabel
</span> for every chunk, with a unique name, which is then used to print out it's navigation hints.
</div>
<div class="Standard">
We also define a regular label for this chunk, as was mentioned above when we calculated 
<span class="code">
\nextchunkname
</span>. This requires LaTeX to be run at least twice after new chunk sections are added --- but noweb requried that anyway.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  \sublabel{\chunkname}%
% define this label for every chunk instance, so we
% can tell when we are the last chunk of this name
  \label{label-\chunkname}%
</code>
</div>
</div>
</div>
<div class="Standard">
We also try and add the chunk to the list of listings, but I'm afraid we don't do very well. We want each chunk name listing once, with all of it's references.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  \addcontentsline{lol}{lstlisting}{\lst@name~[\protect\subpageref{\chunkname}]}%
</code>
</div>
</div>
</div>
<div class="Standard">
We then call the noweb output macros in the same way that noweave generates them, except that we don't need to call 
<span class="code">
\nwstartdeflinemarkup
</span> or 
<span class="code">
\nwenddeflinemarkup
</span> -- and if we do it messes up the output somewhat.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">  \nwmargintag{%
    {%
      \nwtagstyle{}%
      \subpageref{\chunkname}%
    }%
  }%
%
  \moddef{%
    {\lst@name}%
    {%
      \nwtagstyle{}\/%
      \@ifundefined{fangle@chunk@params}{}{%
        (\fangle@chunk@params)%
      }%
      [\csname \chunkcount\endcsname]~%
      \subpageref{\firstchunkname}%
    }%
    \@ifundefined{fangle@chunk@append}{}{%
    \ifx{}\fangle@chunk@append{x}\else%
        ,~add~to~\fangle@chunk@append%
    \fi%
    }%
\global\def\fangle@chunk@append{}%
\lstset{append=x}%
  }%
%
  \ifx\relax\prevchunkname\endmoddef\else\plusendmoddef\fi%
%  \nwstartdeflinemarkup%
  \nwprevnextdefs{\prevchunkname}{\nextchunkname}%
%  \nwenddeflinemarkup%
}%
</code>
</div>
</div>
</div>
<div class="Standard">
Originally this was developed as a 
<span class="code">
listings
</span> aspect, in the Init hook, but it was found easier to affect the title without using a hook --- 
<span class="code">
\lst@AddToHookExe{PreSet}
</span> is still required to set the listings name to the name passed to the 
<span class="code">
\Chunk
</span> command, though.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">%\lst@BeginAspect{fangle}
%\lst@Key{fangle}{true}[t]{\lstKV@SetIf{#1}{true}}
\lst@AddToHookExe{PreSet}{\global\let\lst@intname\lst@chunkname}
\lst@AddToHook{Init}{}%\fangle@caption}
%\lst@EndAspect
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.2.4">13.2.4</a> Cross references
</h3>
<div class="Standard">
We define the \chunkref command which makes it easy to generate visual references to different code chunks, e.g.
</div>
<div class="Standard">

<table>

<tr>

<td align="center" valign="top">
Macro
</td>
<td align="center" valign="top">
Appearance
</td>
</tr>
<tr>

<td align="center" valign="top">
\chunkref{preamble}
</td>
<td align="center" valign="top">

</td>
</tr>
<tr>

<td align="center" valign="top">
\chunkref[3]{preamble}
</td>
<td align="center" valign="top">

</td>
</tr>
<tr>

<td align="center" valign="top">
\chunkref{preamble}[arg1, arg2]
</td>
<td align="center" valign="top">

</td>
</tr>
</table>
</div>
<div class="Standard">
Chunkref can also be used within a code chunk to include another code chunk. The third optional parameter to chunkref is a comma sepatarated list of arguments, which will replace defined parameters in the chunkref.
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">\def\chunkref@args#1,{%
  \def\arg{#1}%
  \lst@ReplaceIn\arg\lst@filenamerpl%
  \arg%
  \@ifnextchar){\relax}{, \chunkref@args}%
}%
\newcommand\chunkref[2][0]{%
  \@ifnextchar({\chunkref@i{#1}{#2}}{\chunkref@i{#1}{#2}()}%
}%
\def\chunkref@i#1#2(#3){%
  \def\zero{0}%
  \def\chunk{#2}%
  \def\chunkno{#1}%
  \def\chunkargs{#3}%
  \ifx\chunkno\zero%
    \def\chunkname{#2-1}%
  \else%
    \def\chunkname{#2-\chunkno}%
  \fi%
  \let\lst@arg\chunk%
  \lst@ReplaceIn\chunk\lst@filenamerpl%
  \LA{%\moddef{%
    {\chunk}%
    {%
      \nwtagstyle{}\/%
      \ifx\chunkno\zero%
      \else%
      [\chunkno]%
      \fi%
      \ifx\chunkargs\empty%
      \else%
        (\chunkref@args #3,)%
      \fi%
      ~\subpageref{\chunkname}%
    }%
  }%
  \RA%\endmoddef%
}%
</code>
</div>
</div>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-13.2.5">13.2.5</a> The end
</h3>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">%
%\makeatother
</code>
</div>
</div>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-14">14</a> Extracting fangle
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-14.1">14.1</a> Extracting from Lyx
</h2>
<div class="Standard">
To extract from LyX, you will need to configure LyX as explained in section <a class="Reference" href="#sub:Configuring-the-build">3.1.2?</a>.
</div>
<div class="Standard">
<a class="Label" name="lyx-build-script"> </a>And this lyx-build scrap will extract fangle for me.
</div>
<div class="Chunk">
lyx-build,language=sh
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">#! /bin/sh
set -x

=&lt;\chunkref{lyx-build-helper}&gt;
cd $PROJECT_DIR || exit 1

=&lt;\chunkref{generate-documentation}&gt;

/usr/local/bin/fangle -R./newfangle $TEX_SRC &gt; ./newfangle
/usr/local/bin/fangle -R./newfangle.module $TEX_SRC &gt; ./newfangle.module

=&lt;\chunkref{test:helpers}&gt;
export FANGLE=./fangle
export TMP=${TMP:-/tmp}
=&lt;\chunkref{test:run-tests}&gt;
# Now check that we can extract a fangle that also passes the tests!
$FANGLE -R./fangle $TEX_SRC &gt; ./new-newfangle
export FANGLE=./new-fangle
=&lt;\chunkref{test:run-tests}&gt;
</code>
</div>
</div>
</div>
<div class="Chunk">
test:run-tests
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing"># run tests
$FANGLE -Rpca-test.awk $TEX_SRC | awk -f - || exit 1
=&lt;\chunkref{test:cromulence}&gt;
=&lt;\chunkref{test:escapes}&gt;
=&lt;\chunkref{test:chunk-params}&gt;
</code>
</div>
</div>
</div>
<div class="Standard">
With a lyx-build-helper
</div>
<div class="Chunk">
lyx-build-helper,language=sh
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">PROJECT_DIR="$LYX_r"
LYX_SRC="$PROJECT_DIR/${LYX_i%.tex}.lyx"
TEX_DIR="$LYX_p"
TEX_SRC="$TEX_DIR/$LYX_i"
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-14.2">14.2</a> Extracting documentation
</h2>
<div class="Chunk">
generate-documentation
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">python -m elyxer --css lyx.css $LYX_SRC | \
  iconv -c -f utf-8 -t ISO-8859-1//TRANSLIT | \
  sed 's/UTF-8"\(.\)&gt;/ISO-8859-1"\1&gt;/' &gt; www/docs/fangle.html

( mkdir -p www/docs/literate &amp;&amp; cd www/docs/literate &amp;&amp; \
  lyx -e latex ../../../literate.lyx &amp;&amp; htlatex ../../../literate.tex "xhtml,fn-in" )
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-14.3">14.3</a> Extracting from the command line
</h2>
<div class="Standard">
First you will need the tex output, then you can extract:
</div>
<div class="Chunk">
lyx-build-manual,language=sh
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">lyx -e latex fangle.lyx
fangle -R./newfangle newfangle.tex &gt; ./newfangle
fangle -R./newfangle.module newfangle.tex &gt; ./newfangle.module
</code>
</div>
</div>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-14.4">14.4</a> Testing
</h2>
<div class="Chunk">
test:helpers
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">passtest() {
  if "$@"
  then echo "Passed"
  else echo "Failed"
       return 1
  fi
}

failtest() {
  if ! "$@"
  then echo "Passed"
  else echo "Failed"
       return 1
  fi
}
</code>
</div>
</div>
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-3">Part 3.</a> Tests
</h1>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-15">15</a> Chunk Parameters
</h1>
<div class="Chunk">
test:chunk-params:sub,language=,params=THING;colour
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">I see a ${THING},
a ${THING} of colour ${colour}, 
and looking closer =&lt;\chunkref{test:chunk-params:sub:sub}(${colour})&gt;
</code>
</div>
</div>
</div>
<div class="Chunk">
test:chunk-params:sub:sub,params=colour,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">a funny shade of ${colour}
</code>
</div>
</div>
</div>
<div class="Chunk">
test:chunk-params:text,language=
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">What do you see? "=&lt;\chunkref{test:chunk-params:sub}(joe, red)&gt;"
Well, fancy!
</code>
</div>
</div>
</div>
<div class="Standard">
Should generate output:
</div>
<div class="Chunk">
test:chunk-params:result
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">What do you see? "I see a joe,
                  a joe of colour red, 
                  and looking closer a funny shade of red"
Well, fancy!
</code>
</div>
</div>
</div>
<div class="Standard">
And this chunk will perform the test:
</div>
<div class="Chunk">
test:chunk-params
</div>
<div class="Standard">

<div class="float">

<div class="listing">
<code class="listing">$FANGLE -Rtest:chunk-params:result $TEX_SRC &gt; $TMP/answer || exit 1
$FANGLE -Rtest:chunk-params:text $TEX_SRC &gt; $TMP/result || exit 1
passtest diff $TMP/answer $TMP/result || (echo test:chunk-params:text failed ; exit 1)
</code>
</div>
</div>
</div>

<hr/>
<p>Copyright (C) 2010 Sam Liddicott</p>
</div>
</body>
</html>
